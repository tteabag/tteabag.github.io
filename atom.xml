<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tteabag</title>
  
  <subtitle>You never know what you can do till you try!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-11T07:38:56.445Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>tteabag</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>catalyst</title>
    <link href="http://example.com/2023/04/11/catalyst/"/>
    <id>http://example.com/2023/04/11/catalyst/</id>
    <published>2023-04-11T06:05:59.000Z</published>
    <updated>2023-04-11T07:38:56.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Catalyst"><a href="#Catalyst" class="headerlink" title="Catalyst"></a>Catalyst</h1><h3 id="什么是Catalyst"><a href="#什么是Catalyst" class="headerlink" title="什么是Catalyst?"></a>什么是<code>Catalyst</code>?</h3><p>It is Apple’s mechanism for bringing iPad apps to the Mac.</p><p>Introduced in <code>macOS 10.15</code>.</p><p>It’s not AppKit but UIKit running under the x86 architecture, rendering Mac-style UI.</p><h3 id="如何将实施Catalyst"><a href="#如何将实施Catalyst" class="headerlink" title="如何将实施Catalyst"></a>如何将实施Catalyst</h3><p><code>Catalyst</code>基于iPad App进行mac适配，所以对于iPhone App需要先进行iPad适配在进行mac适配。</p><p>可以直接添加iPad和mac Destination，而不进行适配，此时在其他平台的表现和iPhone一致。但需要修改iPad 的 present crash。</p><h5 id="iPad-适配"><a href="#iPad-适配" class="headerlink" title="iPad 适配"></a>iPad 适配</h5><ul><li><p>适配SplitViewController</p></li><li><p>Drag &amp; Drop</p></li><li><p>Setting the Scene &amp; Muti-Window</p></li><li><p>Adding Context</p></li><li><p>The Keyboard &amp; Shortcuts</p></li><li><p>Preferences &amp; Settings Bundle</p></li></ul><h5 id="mac-适配"><a href="#mac-适配" class="headerlink" title="mac 适配"></a>mac 适配</h5><ul><li><p>The Mouse</p><ul><li><p>Pointer Style Providers</p></li><li><p>Adding Effects With Hover Gesture Recognizer &amp; NSCursor</p></li></ul></li><li><p>Menu Bar</p></li><li><p>Toolbar</p></li><li><p>Touch Bar</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Catalyst&quot;&gt;&lt;a href=&quot;#Catalyst&quot; class=&quot;headerlink&quot; title=&quot;Catalyst&quot;&gt;&lt;/a&gt;Catalyst&lt;/h1&gt;&lt;h3 id=&quot;什么是Catalyst&quot;&gt;&lt;a href=&quot;#什么是Catalyst&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>iOS图形渲染流程</title>
    <link href="http://example.com/2022/09/29/iOS%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2022/09/29/iOS%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</id>
    <published>2022-09-29T09:09:39.000Z</published>
    <updated>2022-09-29T09:37:45.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS图层渲染流程"><a href="#iOS图层渲染流程" class="headerlink" title="iOS图层渲染流程"></a>iOS图层渲染流程</h1><p> UIView 的相关属性，是经过了一个<strong>图形渲染</strong>流程，才最终可以在屏幕上成像。本文主要介绍两部分内容：</p><ol><li><p>iOS相关渲染框架</p></li><li><p>Core Animation Pipeline（Core Animation 流水线）</p></li></ol><h3 id="一、iOS渲染框架"><a href="#一、iOS渲染框架" class="headerlink" title="一、iOS渲染框架"></a>一、iOS渲染框架</h3><p>下图所示为iOS图形渲染技术栈，App使用<code>Core Grapics</code>、<code>Core Animation</code>、<code>Core Image</code>等框架来绘制可视化内容。这些框架需要通过<code>Metal</code>（iOS12之前是通过<code>OpenGL ES</code>）来调用GPU进行绘制，最后将绘制好的内容显示在屏幕上。</p><p><img src="/./iOS%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/2912639-13847ffe9bd262a8.png.jpeg"></p><ul><li><h6 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h6></li></ul><p><code>UIKit</code>是iOS的基础视图框架，可以用来构建和管理界面可视化内容，响应用户交互事件。</p><p><code>UIKit</code>自身并不具备在屏幕成像的能力，其主要负责<strong>对用户交互事件的响应</strong>（后面有时间再补一篇事件的传递和响应）。</p><p><code>UIKit</code>中的每一个视图控件内部都有一个关联的 CALayer（后面有时间补一篇UIView和CALayer的联系），对视图控件的任何布局设置，本质上都是对其关联的CALayer进行操作。CALayer是App界面可视化内容的载体。</p><p><code>UIKit</code>只支持iOS。</p><ul><li><h6 id="Core-Aniamtion"><a href="#Core-Aniamtion" class="headerlink" title="Core Aniamtion"></a>Core Aniamtion</h6></li></ul><p><code>Core Animation</code>在开发中经常被用来实现动画效果，本质上是一个复合引擎，主要功能包含：<strong>渲染</strong>、<strong>构建</strong>和<strong>实现动画</strong>。它的职责是尽可能快地组合屏幕上不同的可视内容，这个组合过程是将这些内容分解成一个个独立的图层，并存储在一个叫做<strong>图层树</strong>的体系之中。和UIKit不同，Core Animation是直接作用于CALayer的。</p><p><code>Core Animation</code>支持iOS和macOS。</p><ul><li><h6 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h6></li></ul><p><code>Core Graphics</code> 是一个基于<code>Quartz 2D</code>的高级绘图引擎，提供大量的<strong>低层次</strong>、<strong>轻量级</strong>的2D渲染API。可以用来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建，图像遮罩以及PDF文档的生成和解析。</p><p><code>Core Graphics</code>支持iOS和macOS，在Mac OS X中，Core Graphics 还包括用于处理显示硬件，低级用户输入事件和窗口系统的服务。</p><ul><li><h6 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h6></li></ul><p><code>Core Image</code>是iOS5中引入的一个图片处理框架，里面提供了很多强大高效的图像处理功能。Core Image 可以用来十分轻松地实现<strong>滤镜</strong>以及<strong>图像识别</strong>等功能。</p><ul><li><h6 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h6></li></ul><p><code>OpenGL ES</code>（OpenGL for Embedded Systems），是OpenGL三维图形API的⼦集，针对⼿机、Pad和游戏主机等嵌⼊式设备⽽设计，去除了许多不必要和性能较低的API接⼝。在 Metal 推出之前，iOS相关渲染框架都是基于 OpenGL ES 的。</p><ul><li><h6 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h6></li></ul><p><code>Metal</code>是Apple在WWDC 2014上为游戏开发者推出的新技术框架 ，只支持Apple相关平台。和OpenGL相比，Metal 能够为3D图像提高10倍的渲染性能。从iOS12开始，渲染框架底层都是基于 Metal 实现的。</p><ul><li><h6 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h6></li></ul><p><code>GPU</code>（Graphics Processing Unit），是一种可进行绘图、运算的专用微处理器，它的<strong>高度并行结构</strong>使其在大块数据并行处理的算法中比通用 CPU 更有效。</p><h1 id="二、Core-Animation-Pipeline"><a href="#二、Core-Animation-Pipeline" class="headerlink" title="二、Core Animation Pipeline"></a>二、Core Animation Pipeline</h1><p><img src="/./iOS%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/2912639-4e066be8484fbfbd.png"></p><p>上图描绘了Core Animation流水线的大概流程：</p><ul><li><p>App处理完事件，由Core Animation将渲染任务及相关数据提交给Render Server。</p></li><li><p>Render Server生成渲染指令后，并打包传给GPU</p></li><li><p>再调用GPU渲染，</p></li><li><p>最后由iOS的图像设备进行显示。</p></li></ul><p>下面是每个阶段棘突处理的任务：</p><h5 id="1-Application"><a href="#1-Application" class="headerlink" title="1. Application"></a>1. Application</h5><p>在这个阶段，App响应用户事件后（如点击操作、滑动列表等），若需要更新界面内容，会通过<code>CPU</code>完成对显示内容的计算，如：布局计算、图片解码、图像绘制等。在完成对显示内容的计算之后，App将间接通过<code>UIKit</code>或直接通过<code>Core Animation</code>来更新<strong>图层树</strong>，最后将图层编码后的数据提交给<code>Render Server</code>。主要经历了下面两个步骤：</p><h6 id="1-1-Handle-Events"><a href="#1-1-Handle-Events" class="headerlink" title="1.1 Handle Events"></a>1.1 Handle Events</h6><p>App响应事件，并进行处理（如更新约束）。</p><h6 id="1-2-Commit-Transaction"><a href="#1-2-Commit-Transaction" class="headerlink" title="1.2 Commit Transaction"></a>1.2 Commit Transaction</h6><p>这个阶段细分成下面4步：</p><ul><li><h6 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h6></li></ul><p>构建视图，包括：<code>layoutSubviews</code>方法的重载，<code>addSubview</code>: 方法填充子视图等。CPU在这里完成<strong>视图布局</strong>的相关计算。</p><ul><li><h6 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h6></li></ul><p>绘制视图，本质是绘制位图，设置最终成像的图元数据。重载<code>drawRect</code>方法可以完成自定义视图的绘制。CPU在这里完成<strong>图像绘制</strong>的相关计算。</p><ul><li><h6 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h6></li></ul><p>这个步骤会做一些额外的<code>Core Animation</code>工作，比如<strong>图像解码</strong>和<strong>图像转换</strong>。CPU会在这里对View里的图片进行解码，若CPU不支持该图片格式，则会先进行图像转换，再解码。</p><ul><li><h6 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h6></li></ul><p>将图层进行编码打包，并提交给<code>Render Server</code>。由于图层是以树的结构存在，所以打包操作会递归执行。</p><h5 id="2-Render-Server"><a href="#2-Render-Server" class="headerlink" title="2. Render Server"></a>2. Render Server</h5><p><code>Render Server</code>，即<strong>渲染服务器</strong>，主要完成两个任务：</p><ul><li><h6 id="Decode"><a href="#Decode" class="headerlink" title="Decode"></a>Decode</h6></li></ul><p>解码，将传入的图层信息进行解析并反序列化成<strong>渲染树</strong>（<code>render tree</code>)。</p><ul><li><h6 id="Draw-Calls"><a href="#Draw-Calls" class="headerlink" title="Draw Calls"></a>Draw Calls</h6></li></ul><p>根据渲染树中图层的相关设置属性来生成相应的渲染指令(<code>Metal</code>或<code>OpenGL ES</code>)，并将渲染相关信息传给GPU。</p><h5 id="3-GPU"><a href="#3-GPU" class="headerlink" title="3. GPU"></a>3. GPU</h5><p><code>GPU</code>接收到<code>Render Server</code>传来的渲染信息后，会在收到显示器发送新的<code>VSync</code>信号后才进行渲染，并将渲染结果输出到帧缓冲区（即显存）。</p><h5 id="4-Display"><a href="#4-Display" class="headerlink" title="4. Display"></a>4. Display</h5><p>在接受到显示器发出的新的<code>VSync</code>信号后，<strong>视频控制器</strong>会逐行读取帧缓冲区中的数据，再经过一定的数模转换传递给显示器显示。这个阶段的详情步骤可阅读<a href="https://www.jianshu.com/p/91d5cf01187c">iOS 屏幕图像显示原理</a>。</p><p>作者：东篱采桑人<br>链接：<a href="https://www.jianshu.com/p/cfb08dc42a4e">https://www.jianshu.com/p/cfb08dc42a4e</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上可知，App界面内容显示到屏幕上的流程如下：</p><ol><li><code>App</code>响应交互事件，如：用户的点击操作，需要更新界面布局。</li><li><code>App</code>通过<code>CPU</code>完成对显示内容的计算，如：布局计算、图片解码、图像绘制等。在完成计算后，App更新图层树，并将图层树进行编码打包，然后将数据提交给<code>Render Server</code>。</li><li><code>Render Server</code>将图层数据解码后，生成相应的渲染指令，然后将渲染信息传给<code>GPU</code>。</li><li><code>GPU</code>完成渲染后会将渲染结果存入帧缓存区，再由视频控制器逐行读取数据，经由数模转换后将图像显示在屏幕上。</li></ol><p>引用：</p><p><a href="https://www.jianshu.com/p/cfb08dc42a4e">https://www.jianshu.com/p/cfb08dc42a4e</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS图层渲染流程&quot;&gt;&lt;a href=&quot;#iOS图层渲染流程&quot; class=&quot;headerlink&quot; title=&quot;iOS图层渲染流程&quot;&gt;&lt;/a&gt;iOS图层渲染流程&lt;/h1&gt;&lt;p&gt; UIView 的相关属性，是经过了一个&lt;strong&gt;图形渲染&lt;/strong&gt;流</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>atos</title>
    <link href="http://example.com/2022/09/29/atos/"/>
    <id>http://example.com/2022/09/29/atos/</id>
    <published>2022-09-29T06:18:59.000Z</published>
    <updated>2022-09-29T06:20:02.740Z</updated>
    
    <content type="html"><![CDATA[<p>符号表手动解析命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun atos --arch arm64 -o myapp.app.dSYM/Contents/Resources/DWARF/myapp -l 0x00000001000b4000 0x00000001002abc74</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;符号表手动解析命令&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>iOS图像显示原理</title>
    <link href="http://example.com/2022/09/29/iOS%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/09/29/iOS%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/</id>
    <published>2022-09-29T02:06:17.000Z</published>
    <updated>2022-09-29T09:37:44.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、显示器原理"><a href="#一、显示器原理" class="headerlink" title="一、显示器原理"></a>一、显示器原理</h1><p>目前显示器大体分为<strong>CRT显示器</strong>和<strong>液晶显示器</strong>这两个种类：</p><h4 id="1-CRT显示器"><a href="#1-CRT显示器" class="headerlink" title="1.CRT显示器"></a>1.CRT显示器</h4><p>CRT显示器是靠电子束激发屏幕内的荧光粉来显示图像的，屏幕上的每个像素里都有红绿蓝三种颜色的荧光粉，通过电压驱动电子枪发射三束电子束，分别轰击在像素里的三种颜色荧光粉上，通过调节电压大小来改变荧光粉的明暗，通过调节电压方向来改变电子束击打屏幕的位置，从而显示出完成的图像。</p><h4 id="2-液晶显示器"><a href="#2-液晶显示器" class="headerlink" title="2.液晶显示器"></a>2.液晶显示器</h4><p>液晶是一种介于固体和液体之间的特殊物质，常态下呈液态，光线可以顺利透过。给液晶通电，会改变它的分子排列，再配合偏振光片，就可以改变它的透光性。</p><p>液晶显示器的工作原理就是通过改变加给液晶单元的电压，改变液晶单元的透光性，再配合滤光片，就可以在屏幕上显示画面。</p><h4 id="3-显示器刷新原理"><a href="#3-显示器刷新原理" class="headerlink" title="3.显示器刷新原理"></a>3.显示器刷新原理</h4><p>为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用<strong>硬件时钟</strong>产生一系列的定时信号。</p><ul><li>HSync：当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号，简称 <code>HSync</code>（horizonal synchronization）。</li><li>VSync：当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号，简称<code>VSync</code>（vertical synchronization）。</li></ul><p>显示器通常以“固定频率“进行刷新，这个刷新率就是<code>VSync</code>信号产生的频率。<br>iOS设备的屏幕刷新频率是每秒60帧，平均每16.67ms发出一个<code>VSync</code>。</p><h1 id="二、CPU、GPU以及显示器的协作"><a href="#二、CPU、GPU以及显示器的协作" class="headerlink" title="二、CPU、GPU以及显示器的协作"></a>二、CPU、GPU以及显示器的协作</h1><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，视频控制器收到VSync信号后逐行读取帧缓冲区的数据，再经过一定的数模转换传递给显示器显示。</p><p><img src="/./iOS%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/2912639-8f22965938cf2e06.png" alt="2912639-8f22965938cf2e06.png"></p><p>解决画面撕裂问题：双缓存+VSyn</p><h1 id="三、iOS屏幕刷新机制"><a href="#三、iOS屏幕刷新机制" class="headerlink" title="三、iOS屏幕刷新机制"></a>三、iOS屏幕刷新机制</h1><p>iOS设备采取了如下图所示的<strong>双缓存区+VSync</strong>机制</p><ul><li>GPU 会预先渲染好一帧放入一个缓存区内（前帧缓存）。</li><li>在显示器发出<code>VSync</code>后，视频控制器的指针会指向前帧缓存区并开始读取，GPU开始渲染下一帧，并将渲染结果放入另一个缓存区（后帧缓存）。</li><li>在显示器发出新的<code>VSync</code>后，视频控制器的指针会指向后帧缓存区并开始读取，GPU开始渲染下一帧，并将渲染结果放入前帧缓存区。</li></ul><p><img src="/./iOS%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/2912639-36340186a9e118ff.png"></p><h6 id="双缓存存在的问题："><a href="#双缓存存在的问题：" class="headerlink" title="双缓存存在的问题："></a>双缓存存在的问题：</h6><p>由上文可知，每一帧画面要先经过CPU计算，再经过GPU渲染，最后存入缓存区供视频控制器读取。由于垂直同步的机制，如果在一个<code>VSync</code>时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，而这时显示屏会保留之前的内容不变，也就造成界面卡顿。</p><p>引用：</p><p> <a href="https://www.jianshu.com/p/91d5cf01187c">https://www.jianshu.com/p/91d5cf01187c</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、显示器原理&quot;&gt;&lt;a href=&quot;#一、显示器原理&quot; class=&quot;headerlink&quot; title=&quot;一、显示器原理&quot;&gt;&lt;/a&gt;一、显示器原理&lt;/h1&gt;&lt;p&gt;目前显示器大体分为&lt;strong&gt;CRT显示器&lt;/strong&gt;和&lt;strong&gt;液晶显示器&lt;/st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>离屏渲染</title>
    <link href="http://example.com/2022/09/28/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
    <id>http://example.com/2022/09/28/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</id>
    <published>2022-09-28T09:34:44.000Z</published>
    <updated>2022-09-28T09:34:44.958Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>corner_radius</title>
    <link href="http://example.com/2022/09/28/corner-radius/"/>
    <id>http://example.com/2022/09/28/corner-radius/</id>
    <published>2022-09-28T08:11:15.000Z</published>
    <updated>2022-09-28T08:26:57.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置圆角的四种方法"><a href="#设置圆角的四种方法" class="headerlink" title="设置圆角的四种方法"></a>设置圆角的四种方法</h1><h3 id="1-使用layer的cornerRadius"><a href="#1-使用layer的cornerRadius" class="headerlink" title="1.使用layer的cornerRadius"></a>1.使用layer的cornerRadius</h3><p>当设置了cornerRadius，同时设置了masksToBounds时候，在iOS9一下一定会触发离屏渲染；iOS9以后视情况发生离屏渲染（根据画家算法只要一个渲染步骤不会触发）</p><span id="more"></span><h3 id="2-使用mask"><a href="#2-使用mask" class="headerlink" title="2.使用mask"></a>2.使用mask</h3><p>由于使用mask会触发离屏渲染，故此种方法一定会产生离屏渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CAShapeLayer *mask = [CAShapeLayer new];</span><br><span class="line">mask.path = [UIBezierPath bezierPathWithOvalInRect:view.bounds].CGPath;</span><br><span class="line">view.layer.mask = mask;</span><br></pre></td></tr></table></figure><h3 id="3-使用Core-Graphics重绘"><a href="#3-使用Core-Graphics重绘" class="headerlink" title="3.使用Core Graphics重绘"></a>3.使用Core Graphics重绘</h3><p>此种方式，会消耗CPU，同时新生成的图片会增加内存开销，但不会产生离屏渲染</p><h3 id="4-混合图层"><a href="#4-混合图层" class="headerlink" title="4.混合图层"></a>4.混合图层</h3><p>UI提供中心透明，四周与背景同色图片。不会产生离屏渲染</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.优选“混合图层”方案；</p><p>2.iOS9以上优选“cornerRadius”，如产生离屏渲染，在使用“混合图层”方案；</p><h4 id="tip："><a href="#tip：" class="headerlink" title="tip："></a>tip：</h4><p>iOS9以后，UILabel和UIButton设置layer.cornerRadius、layer.backgroundColor，不设置layer.maskstoBounds不会触发离屏渲染</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设置圆角的四种方法&quot;&gt;&lt;a href=&quot;#设置圆角的四种方法&quot; class=&quot;headerlink&quot; title=&quot;设置圆角的四种方法&quot;&gt;&lt;/a&gt;设置圆角的四种方法&lt;/h1&gt;&lt;h3 id=&quot;1-使用layer的cornerRadius&quot;&gt;&lt;a href=&quot;#1-使用layer的cornerRadius&quot; class=&quot;headerlink&quot; title=&quot;1.使用layer的cornerRadius&quot;&gt;&lt;/a&gt;1.使用layer的cornerRadius&lt;/h3&gt;&lt;p&gt;当设置了cornerRadius，同时设置了masksToBounds时候，在iOS9一下一定会触发离屏渲染；iOS9以后视情况发生离屏渲染（根据画家算法只要一个渲染步骤不会触发）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ios_exception</title>
    <link href="http://example.com/2022/09/23/ios-exception/"/>
    <id>http://example.com/2022/09/23/ios-exception/</id>
    <published>2022-09-23T08:00:27.000Z</published>
    <updated>2022-09-28T08:27:16.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Task-amp-Thread-amp-Process的区别"><a href="#Task-amp-Thread-amp-Process的区别" class="headerlink" title="Task &amp; Thread &amp; Process的区别"></a>Task &amp; Thread &amp; Process的区别</h1><p>iOS操作系统内核为XNU（混合内核），而XNU的核心为Mach微内核。</p><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>用户角度：一个可执行程序的一个实例就是一个进程，使用PID标识<br>BSD层的Process：内部包含多个线程，和Mach Task一一对应</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Mach Task是系统资源的集合，包含：一个虚拟的地址空间（分配内存），一个端口权限名称空间，一个或多个线程。</p><p>Mach Task和Process的区别：Mach Task提供更少的功能。在Process中，有信号、组、文件描述符等。而Mach Task用于资源的分配和共享，它是资源的容器。</p><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>iOS中的进程和POSIX线程（pthread）是分别基于Mach task和Mach thread的顶层实现。</p><p><img src="/./ios-exception/daaf18b3efe543daad508d0d9931ddf8~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image.jpeg"></p><span id="more"></span><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h3 id="异常简述"><a href="#异常简述" class="headerlink" title="异常简述"></a>异常简述</h3><p>应用通常运行在用户态。但是，当应用需要去主动使用系统调用，或被动遇到一些异常或者中断的时，应用由用户态进入到内核态，相当于系统收回了应用的运行权限<br><img src="/./ios-exception/5f23826ebe70464097cf4e869b6fc77e~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image.jpeg"></p><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><ol><li>硬件异常：例如除0操作</li><li>软件异常：给一个不存在的对象发送了消息</li></ol><p>写的软件错误，可造成硬件异常，亦或是软件异常。而只有硬件异常才会发生上述的用户态到内核态的转化。</p><h3 id="Mach-Exception"><a href="#Mach-Exception" class="headerlink" title="Mach Exception"></a>Mach Exception</h3><h4 id="Mach-Exception的传递"><a href="#Mach-Exception的传递" class="headerlink" title="Mach Exception的传递"></a>Mach Exception的传递</h4><p>Mach内核提供了一个基于IPC的异常处理工具，其中异常被转化为message。</p><p>当异常发生时，一条包含异常的mach message，会被发送到一个异常端口。而线程（thread），任务（task），主机（host）都会维护一组异常端口，当Mach Exception机制传递异常消息的时候，它会按照thread → task → host 的顺序传递异常消息（这三者就是线程，进程，和系统的递进关系），如果这三个级别都没有处理异常成功，也就是收到KERN_SUCCESS 结果，那么内核就会终止该进程</p><h4 id="如何处理Mach-Exception？"><a href="#如何处理Mach-Exception？" class="headerlink" title="如何处理Mach Exception？"></a>如何处理Mach Exception？</h4><p>异常处理程序是mach message的接受者，它运行在自己的线程，虽然说它可以和发生异常的线程在同一个task中（也就是同一个进程中），但是它通常运行在其他的task中，比如说一个debugger。</p><p>如果一个线程想处理这个task的异常消息，那么就需要调用task_set_exception_ports() 来注册这个task的异常端口。这样的话，只要这个进程出现了硬件异常最后都会转化为Mach Exception Mesaage并传递给注册的端口，从而被异常处理程序接受到，处理接收到的异常消息。</p><h4 id="Mach-Exception分类"><a href="#Mach-Exception分类" class="headerlink" title="Mach Exception分类"></a>Mach Exception分类</h4><table><thead><tr><th>Exception</th><th>Notes</th></tr></thead><tbody><tr><td>EXC_BAD_ACCESS</td><td>无法访问内存</td></tr><tr><td>EXC_BAD_INSTRUCTION</td><td>非法或者未定义的指令或者操作数</td></tr><tr><td>EXC_ARITHMETIC</td><td>算术异常（例如被零除）</td></tr><tr><td>EXC_EMULATION</td><td>遇到仿真支持指令</td></tr><tr><td>EXC_SOFTWARE</td><td>软件生成的异常（比如浮点数计算的异常）</td></tr><tr><td>EXC_BREAKPOINT</td><td>跟踪或者断点（比如Xcode的断点，就会产生异常）</td></tr><tr><td>EXC_SYSCALL</td><td>Unix系统调用</td></tr><tr><td>EXC_MACH_SYSCALL</td><td>Mach系统调用</td></tr><tr><td>EXC_RPC_ALERTRPC</td><td>警告</td></tr></tbody></table><h3 id="Unix-Signal"><a href="#Unix-Signal" class="headerlink" title="Unix Signal"></a>Unix Signal</h3><p>Mach已经提供了底层的异常机制，但是基于Mach exception，Apple在内核的BSD层上也建立了一套信号处理系统。这是为什么呢？</p><p>原因很简单，其实就是为了兼容Unix系统。而基于Linux的安卓也是兼容Unix的，所以安卓的异常也是抛出的Signal。当然这里得说明，在现代的Unix系统中，Mach异常只是导致信号生成的一类事件，还有很多其他的事件可能也会导致信号的生成，比如：显式的调用kill(2)或者killpg(2)、子线程的状态变化等等。</p><h4 id="MachineException-转-Signal"><a href="#MachineException-转-Signal" class="headerlink" title="MachineException 转 Signal"></a>MachineException 转 Signal</h4><p>Mach异常如果没有在其他地方（thread，task）得到处理，那么它会在ux_exception() 中将其转化为对应的Unix Signal信号，以下是两者之间的转化：</p><table><thead><tr><th>Mach Exception</th><th>Unix Signal</th><th>原因</th></tr></thead><tbody><tr><td>EXC_BAD_INSTRUCTION</td><td>SIGILL</td><td>非法指令，比如除0操作，数组越界，强制解包可选形等等</td></tr><tr><td>EXC_BAD_ACCESS</td><td>SIGSEVG、SIGBUS</td><td>SIGSEVG、SIGBUS两者都是错误内存访问，但是两者之间是有区别的：SIGBUS（总线错误）是内存映射有效，但是不允许被访问； SIGSEVG（段地址错误）是内存地址映射都失效</td></tr><tr><td>EXC_ARIHMETIC</td><td>SIGFPE</td><td>运算错误，比如浮点数运算异常</td></tr><tr><td>EXC_EMULATION</td><td>SIGEM</td><td>Thardware emulation 硬件仿真指令</td></tr><tr><td>EXC_BREAKPOINT</td><td>SIGTRAP</td><td>trace、breakpoint等等，比如说使用Xcode的断点</td></tr><tr><td>EXC_SOFTWARE</td><td>SIGABRT、SIGPIPE、SIGSYS、SIGKILL</td><td>软件错误，其中SIGABRT最为常见。</td></tr></tbody></table><h4 id="软件异常转Signal"><a href="#软件异常转Signal" class="headerlink" title="软件异常转Signal"></a>软件异常转Signal</h4><p>除了上述引发CPU Trap的异常之外，还有一类异常是软件异常，这一类异常并不会让进程进入内核态，所以它也并不会转化为Mach Exception，而是会直接转化为Unix Signal。而由Objective-C产生的异常就是软件异常这一类，它将直接转换为Signal信号，比如给对象发送未实现的消息，数组索引越界直接引发SIGABRT信号，作为对比Swift的数组异常会导致CPU Trap，转化为EXC_BAD_INSTRUCTION异常消息。</p><h4 id="Mach-Exception和Unix-Signal的区别"><a href="#Mach-Exception和Unix-Signal的区别" class="headerlink" title="Mach Exception和Unix Signal的区别"></a>Mach Exception和Unix Signal的区别</h4><p>Mach Exception的处理机制中异常处理程序可以在自己创建的处理线程中运行，而该线程和出错的线程甚至可以不在一个task中，即可以不在一个进程中，因此异常处理不需要错误线程的资源来运行，这样可以在需要的时候直接获得错误线程的异常上下文</p><p>而Unix Signal的处理无法运行在其他的线程，只能在错误线程上处理</p><p>所以Mach异常处理机制的优势是很明显的，比如说debugging场景，我们平时打断点的时候，其实程序运行到这里的时候会给Xcode这个task中的注册异常端口发EXC_BREAKPOINT消息，而Xcode收到之后，就会暂停在断点处，在处理完之后（比如点击跳过断点），将发送消息返回到Xcode，Xcode也将继续跑下去。</p><h1 id="iOS异常捕获三方"><a href="#iOS异常捕获三方" class="headerlink" title="iOS异常捕获三方"></a>iOS异常捕获三方</h1><ol><li><p>SKCrash</p></li><li><p>PLCrashReport</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/7142656591139962888">你真的懂iOS的异常捕获吗？ - 掘金</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Task-amp-Thread-amp-Process的区别&quot;&gt;&lt;a href=&quot;#Task-amp-Thread-amp-Process的区别&quot; class=&quot;headerlink&quot; title=&quot;Task &amp;amp; Thread &amp;amp; Process的区别&quot;&gt;&lt;/a&gt;Task &amp;amp; Thread &amp;amp; Process的区别&lt;/h1&gt;&lt;p&gt;iOS操作系统内核为XNU（混合内核），而XNU的核心为Mach微内核。&lt;/p&gt;
&lt;h3 id=&quot;Process&quot;&gt;&lt;a href=&quot;#Process&quot; class=&quot;headerlink&quot; title=&quot;Process&quot;&gt;&lt;/a&gt;Process&lt;/h3&gt;&lt;p&gt;用户角度：一个可执行程序的一个实例就是一个进程，使用PID标识&lt;br&gt;BSD层的Process：内部包含多个线程，和Mach Task一一对应&lt;/p&gt;
&lt;h3 id=&quot;Task&quot;&gt;&lt;a href=&quot;#Task&quot; class=&quot;headerlink&quot; title=&quot;Task&quot;&gt;&lt;/a&gt;Task&lt;/h3&gt;&lt;p&gt;Mach Task是系统资源的集合，包含：一个虚拟的地址空间（分配内存），一个端口权限名称空间，一个或多个线程。&lt;/p&gt;
&lt;p&gt;Mach Task和Process的区别：Mach Task提供更少的功能。在Process中，有信号、组、文件描述符等。而Mach Task用于资源的分配和共享，它是资源的容器。&lt;/p&gt;
&lt;h3 id=&quot;Thread&quot;&gt;&lt;a href=&quot;#Thread&quot; class=&quot;headerlink&quot; title=&quot;Thread&quot;&gt;&lt;/a&gt;Thread&lt;/h3&gt;&lt;p&gt;iOS中的进程和POSIX线程（pthread）是分别基于Mach task和Mach thread的顶层实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./ios-exception/daaf18b3efe543daad508d0d9931ddf8~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image.jpeg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>operation_queue</title>
    <link href="http://example.com/2022/05/19/%E8%87%AA%E5%AE%9A%E4%B9%89Operation/"/>
    <id>http://example.com/2022/05/19/%E8%87%AA%E5%AE%9A%E4%B9%89Operation/</id>
    <published>2022-05-19T06:52:13.000Z</published>
    <updated>2022-05-19T08:11:36.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义Operation"><a href="#自定义Operation" class="headerlink" title="自定义Operation"></a>自定义Operation</h1><p>operation分两种，同步和异步</p><h2 id="1-同步"><a href="#1-同步" class="headerlink" title="1.同步"></a>1.同步</h2><p> 同步的定义，只需要重写main()方法，main方法内部不能调用其他异步函数，因为main()方法执行完成，operation即执行结束。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SyncOperation: Operation &#123;   </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        print(&quot;执行同步任务&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-异步"><a href="#2-异步" class="headerlink" title="2.异步"></a>2.异步</h2><p>异步方法需要重写如下方法：</p><ul><li>var isAsynchronous: Bool { get }</li><li>override var isExecuting: Bool { get }</li><li>override var isFinished: Bool { get }</li></ul><p>OperationQueue通过监听上面方法确定任务的状态，然后在start()方法中执行任务（可以调用异步方法），根据任务结果更新状态。</p><p>可重写cancel方法，cancel方法中一定要更新isFinished=true，不然operation不会从OperationQueue的operations中删除，operation会一直不会结束</p><blockquote><p>Tip：异步方法isAsynchronous需要返回true</p></blockquote><p>demo如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private class BaseOperation: Operation &#123;</span><br><span class="line">    enum State: String &#123;</span><br><span class="line">        case ready = &quot;Ready&quot;</span><br><span class="line">        case executing = &quot;Executing&quot;</span><br><span class="line">        case finished = &quot;Finished&quot;</span><br><span class="line">        fileprivate var keyPath: String &#123; return &quot;is&quot; + self.rawValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override var isAsynchronous: Bool &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    override var isExecuting: Bool &#123;</span><br><span class="line">        return state == .executing</span><br><span class="line">    &#125;</span><br><span class="line">    override var isFinished: Bool &#123;</span><br><span class="line">        return state == .finished</span><br><span class="line">    &#125;</span><br><span class="line">    private var state = State.ready &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            willChangeValue(forKey: state.keyPath)</span><br><span class="line">            willChangeValue(forKey: newValue.keyPath)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            didChangeValue(forKey: state.keyPath)</span><br><span class="line">            didChangeValue(forKey: oldValue.keyPath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func start() &#123;</span><br><span class="line">        if isCancelled &#123;</span><br><span class="line">            state = .finished</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            state = .ready</span><br><span class="line">            main()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        state = self.isCancelled ? .finished : .executing</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func finish(error: Error?) &#123;</span><br><span class="line">        state = .finished</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private class UploadOperation: BaseOperation &#123;</span><br><span class="line">    override func start() &#123;</span><br><span class="line">        super.start()</span><br><span class="line">        /// 执行任务，更新状态  </span><br><span class="line">    &#125;</span><br><span class="line">    override func cancel() &#123;</span><br><span class="line">        super.cancel()</span><br><span class="line">        /// 这里一定要更新状态</span><br><span class="line">        finish(error: nil)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;自定义Operation&quot;&gt;&lt;a href=&quot;#自定义Operation&quot; class=&quot;headerlink&quot; title=&quot;自定义Operation&quot;&gt;&lt;/a&gt;自定义Operation&lt;/h1&gt;&lt;p&gt;operation分两种，同步和异步&lt;/p&gt;
&lt;h2 id=&quot;1-同步&quot;&gt;&lt;a href=&quot;#1-同步&quot; class=&quot;headerlink&quot; title=&quot;1.同步&quot;&gt;&lt;/a&gt;1.同步&lt;/h2&gt;&lt;p&gt; 同步的定义，只需要重写main()方法，main方法内部不能调用其他异步函数，因为main()方法执行完成，operation即执行结束。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>swift_concurrency</title>
    <link href="http://example.com/2022/05/17/Swift%20Concurrency/"/>
    <id>http://example.com/2022/05/17/Swift%20Concurrency/</id>
    <published>2022-05-17T03:31:35.000Z</published>
    <updated>2022-09-28T08:25:55.645Z</updated>
    
    <content type="html"><![CDATA[<p>Swift Concurrency</p><h1 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h1><h2 id="一-怎样调用第一个async函数"><a href="#一-怎样调用第一个async函数" class="headerlink" title="一.怎样调用第一个async函数"></a>一.怎样调用第一个async函数</h2><p>情况1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func processWeather() async &#123;</span><br><span class="line">    // Do async work here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line">struct MainApp &#123;</span><br><span class="line">    static func main() async &#123;</span><br><span class="line">        await processWeather()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>情况2：SwiftUI相关modifiers，如refreshable() and task()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    @State private var sourceCode = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        ScrollView &#123;</span><br><span class="line">            Text(sourceCode)</span><br><span class="line">        &#125;</span><br><span class="line">        .task &#123;</span><br><span class="line">            await fetchSource()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func fetchSource() async &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            let url = URL(string: &quot;https://apple.com&quot;)!</span><br><span class="line"></span><br><span class="line">            let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">            sourceCode = String(decoding: data, as: UTF8.self).trimmingCharacters(in: .whitespacesAndNewlines)</span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">            sourceCode = &quot;Failed to fetch apple.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况三：使用Task api</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Button(&quot;Go&quot;) &#123;</span><br><span class="line">    Task &#123;</span><br><span class="line">        await fetchSource()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-性能消耗"><a href="#2-性能消耗" class="headerlink" title="2.性能消耗"></a>2.性能消耗</h2><ul><li>只要使用await，就会产生一个潜在的暂停点，swift无法判断在暂停点是否一定会暂停，固在await出一定会产生”calling convention”消耗；</li><li>暂停点如果没有暂停，则和synchronous方式一样，没得额外消耗，如果暂停，那一定是赚了</li></ul><h2 id="3-怎样创建使用异步属性（async-properties）"><a href="#3-怎样创建使用异步属性（async-properties）" class="headerlink" title="3.怎样创建使用异步属性（async properties）"></a>3.怎样创建使用异步属性（async properties）</h2><p>异步属性只能用于<strong>只读计算属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct RemoteFile&lt;T: Decodable&gt; &#123;</span><br><span class="line">    let url: URL</span><br><span class="line">    let type: T.Type</span><br><span class="line"></span><br><span class="line">    // 定义</span><br><span class="line">    var contents: T &#123;</span><br><span class="line">        get async throws &#123;</span><br><span class="line">            let (data, _) = try await URLSession.noCacheSession.data(from: url)</span><br><span class="line">            return try JSONDecoder().decode(T.self, from: data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">Task &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        messages = try await source.contents</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;Message update failed.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-async-let的使用"><a href="#4-async-let的使用" class="headerlink" title="4.async let的使用"></a>4.async let的使用</h2><p>async let，相当于DispathGroup，各个任务互相独立，同时执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func loadData() async &#123;</span><br><span class="line">    async let (userData, _) = URLSession.shared.data(from: URL(string: &quot;https://hws.dev/user-24601.json&quot;)!)</span><br><span class="line">    async let (messageData, _) = URLSession.shared.data(from: URL(string: &quot;https://hws.dev/user-messages.json&quot;)!)</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        let decoder = JSONDecoder()</span><br><span class="line">        let user = try await decoder.decode(User.self, from: userData)</span><br><span class="line">        let messages = try await decoder.decode([Message].self, from: messageData)</span><br><span class="line">        print(&quot;User \(user.name) has \(messages.count) message(s).&quot;)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;Sorry, there was a network problem.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-将block转换成async"><a href="#5-将block转换成async" class="headerlink" title="5.将block转换成async"></a>5.将block转换成async</h2><p>涉及函数<code>withCheckedContinuation </code>、<code>withUnsafeContinuation </code>、<code>withUnsafeThrowingContinuation </code>、<code>withCheckedThrowingContinuation </code>，<br>check函数会检查正确性，当多次resume，或者没有resume，都会导致crash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func fetchMessages() async -&gt; [Message] &#123;</span><br><span class="line">    await withCheckedContinuation &#123; continuation in</span><br><span class="line">        fetchMessages &#123; messages in</span><br><span class="line">            continuation.resume(returning: messages)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fetchMessages() async -&gt; [Message] &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        return try await withCheckedThrowingContinuation &#123; continuation in</span><br><span class="line">            fetchMessages &#123; messages in</span><br><span class="line">                if messages.isEmpty &#123;</span><br><span class="line">                    continuation.resume(throwing: FetchError.noMessages)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continuation.resume(returning: messages)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        return [</span><br><span class="line">            Message(id: 1, from: &quot;Tom&quot;, message: &quot;Welcome to MySpace! I&#x27;m your new friend.&quot;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-Sequences-and-streams"><a href="#二-Sequences-and-streams" class="headerlink" title="二.Sequences and streams"></a>二.Sequences and streams</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/// for in</span><br><span class="line">func fetchUsers() async throws &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/users.csv&quot;)!</span><br><span class="line"></span><br><span class="line">    for try await line in url.lines &#123;</span><br><span class="line">        print(&quot;Received user: \(line)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// Iterator</span><br><span class="line">func printUsers() async throws &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/users.csv&quot;)!</span><br><span class="line">    var iterator = url.lines.makeAsyncIterator()</span><br><span class="line"></span><br><span class="line">    if let line = try await iterator.next() &#123;</span><br><span class="line">        print(&quot;The first user is \(line)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// map\filiter\prefix...</span><br><span class="line">func shoutQuotes() async throws &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/quotes.txt&quot;)!</span><br><span class="line">    let uppercaseLines = url.lines.map(\.localizedUppercase)</span><br><span class="line"></span><br><span class="line">    for try await line in uppercaseLines &#123;</span><br><span class="line">        print(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// 返回不透明类型opaque return type</span><br><span class="line">func getQuotes() async -&gt; some AsyncSequence &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/quotes.txt&quot;)!</span><br><span class="line">    let anonymousQuotes = url.lines.filter &#123; $0.contains(&quot;Anonymous&quot;) &#125;</span><br><span class="line">    let topAnonymousQuotes = anonymousQuotes.prefix(5)</span><br><span class="line">    let shoutingTopAnonymousQuotes = topAnonymousQuotes.map(\.localizedUppercase)</span><br><span class="line">    return shoutingTopAnonymousQuotes</span><br><span class="line">&#125;</span><br><span class="line">/// convert an AsyncSequence into a Sequence</span><br><span class="line">extension AsyncSequence &#123;</span><br><span class="line">    func collect() async rethrows -&gt; [Element] &#123;</span><br><span class="line">        try await reduce(into: [Element]()) &#123; $0.append($1) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、Task-TaskGroup"><a href="#三、Task-TaskGroup" class="headerlink" title="三、Task\TaskGroup"></a>三、Task\TaskGroup</h1><h2 id="1-创建Task"><a href="#1-创建Task" class="headerlink" title="1.创建Task"></a>1.创建Task</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func fetchUpdates() async &#123;</span><br><span class="line">    let newsTask = Task &#123; () -&gt; [NewsItem] in</span><br><span class="line">        let url = URL(string: &quot;https://hws.dev/headlines.json&quot;)!</span><br><span class="line">        let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">        return try JSONDecoder().decode([NewsItem].self, from: data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        let highScores = try await highScoreTask.value</span><br><span class="line">        print(&quot;Latest news loaded with \(news.count) items.&quot;)</span><br><span class="line">        if let topScore = highScores.first &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Task-init和Task-detached的区别"><a href="#2-Task-init和Task-detached的区别" class="headerlink" title="2.Task.init和Task.detached的区别"></a>2.Task.init和Task.detached的区别</h2><h2 id="3-获取Task的结果result"><a href="#3-获取Task的结果result" class="headerlink" title="3.获取Task的结果result"></a>3.获取Task的结果result</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func fetchQuotes() async &#123;</span><br><span class="line">    let downloadTask = Task &#123; () -&gt; String in</span><br><span class="line">        let url = URL(string: &quot;https://hws.dev/quotes.txt&quot;)!</span><br><span class="line">        let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">        return String(decoding: data, as: UTF8.self)</span><br><span class="line">    &#125;</span><br><span class="line">    let result = await downloadTask.result</span><br><span class="line">    do &#123;</span><br><span class="line">        let string = try result.get()</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-取消任务"><a href="#4-取消任务" class="headerlink" title="4.取消任务"></a>4.取消任务</h2><p>检查任务：<code>Task.checkCancellation()</code>和<code>Task.isCancelled</code></p><p>取消任务：<code>task.cancel()</code></p><h2 id="5-Task睡眠"><a href="#5-Task睡眠" class="headerlink" title="5.Task睡眠"></a>5.Task睡眠</h2><p>task sleep不会导致thread block<br><code>try await Task.sleep(nanoseconds: 3_000_000_000)</code></p><h2 id="6-自愿暂停任务"><a href="#6-自愿暂停任务" class="headerlink" title="6.自愿暂停任务"></a>6.自愿暂停任务</h2><p>自愿暂停任务，可以让其他任务执行机会，但不一定会暂停（优先级最高）<br><code>await Task.yield()</code></p><h2 id="7-创建TaskGroup"><a href="#7-创建TaskGroup" class="headerlink" title="7.创建TaskGroup"></a>7.创建TaskGroup</h2><p>两个方法<code>withTaskGroup </code>和<code>withThrowingTaskGroup </code>，另外TaskGroup遵循<code>AsyncSequence </code>协议，TaskGroup只能返回同一Type数据</p><p>cancel TaskGroup分三种情况：</p><ul><li>父Task被取消</li><li>显示的调用cancelAll()</li><li>其中一个子任务throws未捕获的错误</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func loadStories() async &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        stories = try await withThrowingTaskGroup(of: [NewsStory].self) &#123; group -&gt; [NewsStory] in</span><br><span class="line">            for i in 1...5 &#123;</span><br><span class="line">                group.addTask &#123;</span><br><span class="line">                    let url = URL(string: &quot;https://hws.dev/news-\(i).json&quot;)!</span><br><span class="line">                    let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">                    return try JSONDecoder().decode([NewsStory].self, from: data)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            let allStories = try await group.reduce(into: [NewsStory]()) &#123; $0 += $1 &#125;</span><br><span class="line">            return allStories.sorted &#123; $0.id &gt; $1.id &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-处理TaskGroup返回不同数据类型"><a href="#8-处理TaskGroup返回不同数据类型" class="headerlink" title="8.处理TaskGroup返回不同数据类型"></a>8.处理TaskGroup返回不同数据类型</h2><p>两种方式：</p><ul><li>使用<code>async let</code></li><li>使用enum+关联类型</li></ul><h2 id="9-TaskLocal"><a href="#9-TaskLocal" class="headerlink" title="9.TaskLocal"></a>9.TaskLocal</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">enum User &#123;</span><br><span class="line">    @TaskLocal static var id = &quot;Anonymous&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line">struct App &#123;</span><br><span class="line">    static func main() async throws &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            try await User.$id.withValue(&quot;Piper&quot;) &#123;</span><br><span class="line">                print(&quot;Start of task: \(User.id)&quot;)</span><br><span class="line">                try await Task.sleep(nanoseconds: 1_000_000)</span><br><span class="line">                print(&quot;End of task: \(User.id)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Task &#123;</span><br><span class="line">            try await User.$id.withValue(&quot;Alex&quot;) &#123;</span><br><span class="line">                print(&quot;Start of task: \(User.id)&quot;)</span><br><span class="line">                try await Task.sleep(nanoseconds: 1_000_000)</span><br><span class="line">                print(&quot;End of task: \(User.id)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(&quot;Outside of tasks: \(User.id)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-task-modifier"><a href="#10-task-modifier" class="headerlink" title="10.task modifier"></a>10.task modifier</h2><blockquote><p>task modifier 在onAppear调用，在onDisappear时cancel，为了避免反复调用，使用task(id:)</p></blockquote><h1 id="四-Actor"><a href="#四-Actor" class="headerlink" title="四.Actor"></a>四.Actor</h1><p>actior特点如下：</p><ul><li>actor关键词同struct、class同级</li><li>actor和class一致，都是引用类型，但actor不能继承，也就不能使用final、override关键词。</li><li>actor自动继承Actor协议</li></ul><blockquote><p>actor是线程安全的，外部访问actor的mutable state需要使用await</p></blockquote><blockquote><p>使用isolated关键词，不会要求使用await</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actor DataStore &#123;</span><br><span class="line">    var username = &quot;Anonymous&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func debugLog(dataStore: isolated DataStore) &#123;</span><br><span class="line">    print(&quot;Username: \(dataStore.username)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>actor 内部使用<code>nonisolated </code>，方法和计算属性可以使用</li><li>访问使用<code>nonisolated </code>的方法属性不需要加<code>await</code></li><li>nonisolated方法内部只能访问nonisolated方法不需要加await</li><li>Codable等协议方法需要使用上<code>nonisolated </code>关键词</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">actor User &#123;</span><br><span class="line">    let username: String</span><br><span class="line">    let password: String</span><br><span class="line">    var isOnline = false</span><br><span class="line"></span><br><span class="line">    init(username: String, password: String) &#123;</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nonisolated func passwordHash() -&gt; String &#123;</span><br><span class="line">        return password</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = User(username: &quot;twostraws&quot;, password: &quot;s3kr1t&quot;)</span><br><span class="line">print(user.passwordHash())</span><br></pre></td></tr></table></figure><h2 id="1-MainActor"><a href="#1-MainActor" class="headerlink" title="1.MainActor"></a>1.MainActor</h2><p>MainActor是一个全局的actor，保证所以的work在主线程执行。<br>被@MainActor标记的方法、类型可以安全的操作UI<br>MainActor.run可以将任务放在主线程执行</p><p>demo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@MainActor</span><br><span class="line">class AccountViewModel: ObservableObject &#123;</span><br><span class="line">    @Published var username = &quot;Anonymous&quot;</span><br><span class="line">    @Published var isAuthenticated = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await MainActor.run &#123;</span><br><span class="line">    print(&quot;This is on the main actor.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task &#123;</span><br><span class="line">    await MainActor.run &#123;</span><br><span class="line">        print(&quot;This is on the main actor.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task &#123; @MainActor in</span><br><span class="line">    print(&quot;This is on the main actor.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Swift Concurrency&lt;/p&gt;
&lt;h1 id=&quot;Async-await&quot;&gt;&lt;a href=&quot;#Async-await&quot; class=&quot;headerlink&quot; title=&quot;Async/await&quot;&gt;&lt;/a&gt;Async/await&lt;/h1&gt;&lt;h2 id=&quot;一-怎样调用第一个async函数&quot;&gt;&lt;a href=&quot;#一-怎样调用第一个async函数&quot; class=&quot;headerlink&quot; title=&quot;一.怎样调用第一个async函数&quot;&gt;&lt;/a&gt;一.怎样调用第一个async函数&lt;/h2&gt;&lt;p&gt;情况1：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func processWeather() async &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Do async work here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct MainApp &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static func main() async &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        await processWeather()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>xcode_preview_crash</title>
    <link href="http://example.com/2022/05/13/Xcode%20preview%20crash/"/>
    <id>http://example.com/2022/05/13/Xcode%20preview%20crash/</id>
    <published>2022-05-13T09:25:15.000Z</published>
    <updated>2022-05-13T09:29:48.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xcode-Preview-Crash"><a href="#Xcode-Preview-Crash" class="headerlink" title="Xcode Preview Crash"></a>Xcode Preview Crash</h1><p>结论，运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl --set previews delete all</span><br></pre></td></tr></table></figure><p>崩溃原因：使用了realmswift，然后修改了Object，按照常理说删除应用后，在migration的时候就不会崩溃；但preview不得行，一样会崩溃，猜测是preview应用缓存在其他位置，不是模拟器上看到的那个应用。</p><p>网上找到的解决方法：<br>终端运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl --set previews delete all</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Xcode-Preview-Crash&quot;&gt;&lt;a href=&quot;#Xcode-Preview-Crash&quot; class=&quot;headerlink&quot; title=&quot;Xcode Preview Crash&quot;&gt;&lt;/a&gt;Xcode Preview Crash&lt;/h1&gt;&lt;p&gt;结论</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大杂烩</title>
    <link href="http://example.com/2022/03/10/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>http://example.com/2022/03/10/%E5%A4%A7%E6%9D%82%E7%83%A9/</id>
    <published>2022-03-10T10:21:58.000Z</published>
    <updated>2022-10-04T01:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Xcode在Resolve Package Dependencies时候慢的解决方式</p><p> 原因：是xcode网络请求不会走代理</p><p> 解决方式：终端挂代理，在项目root path使用<code>xcodebuild -resolvePackageDependencies -scmProvider system</code></p></li><li><p>Xcode添加swift package时慢的处理方法</p><p> 使用软件Proxifier软件，在打开xcode</p></li><li><p>terminal指定应用打开文件<br><code>open -a \Application\xx.app xx</code></p></li><li><p>Xcode显示Products目录</p></li></ol><p>        打开.pbxproj文件，搜索mainGroup，将mainGroup的值复制给productRefGroup</p><p>   5. sizeof 是一个函数</p><p>   6.atomic不是线程安全的，具体是在NSMutableArray这种类型上不安全        </p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Xcode在Resolve Package Dependencies时候慢的解决方式&lt;/p&gt;
&lt;p&gt; 原因：是xcode网络请求不会走代理&lt;/p&gt;
&lt;p&gt; 解决方式：终端挂代理，在项目root path使用&lt;code&gt;xcodebuild -resolvePackageDependencies -scmProvider system&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Xcode添加swift package时慢的处理方法&lt;/p&gt;
&lt;p&gt; 使用软件Proxifier软件，在打开xcode&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;terminal指定应用打开文件&lt;br&gt;&lt;code&gt;open -a \Application\xx.app xx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Xcode显示Products目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;        打开.pbxproj文件，搜索mainGroup，将mainGroup的值复制给productRefGroup&lt;/p&gt;
&lt;p&gt;   5. sizeof 是一个函数&lt;/p&gt;
&lt;p&gt;   6.atomic不是线程安全的，具体是在NSMutableArray这种类型上不安全        &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>博客的诞生</title>
    <link href="http://example.com/2021/12/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/"/>
    <id>http://example.com/2021/12/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/</id>
    <published>2021-12-19T06:22:33.000Z</published>
    <updated>2021-12-19T06:24:11.325Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下博客的诞生日期：2021-12-19，今天算是第一篇文章，再接再厉！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下博客的诞生日期：2021-12-19，今天算是第一篇文章，再接再厉！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
