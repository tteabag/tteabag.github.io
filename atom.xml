<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tteabag</title>
  
  <subtitle>You never know what you can do till you try!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-19T07:22:34.844Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>tteabag</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>operation_queue</title>
    <link href="http://example.com/2022/05/19/operation-queue/"/>
    <id>http://example.com/2022/05/19/operation-queue/</id>
    <published>2022-05-19T06:52:13.000Z</published>
    <updated>2022-05-19T07:22:34.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义Operation"><a href="#自定义Operation" class="headerlink" title="自定义Operation"></a>自定义Operation</h1><p>operation分两种，同步和异步</p><h2 id="1-同步"><a href="#1-同步" class="headerlink" title="1.同步"></a>1.同步</h2><p> 同步的定义，只需要重写main()方法，main方法内部不能调用其他异步函数，因为main()方法执行完成，operation即执行结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SyncOperation: Operation &#123;   </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        print(&quot;执行同步任务&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-异步"><a href="#2-异步" class="headerlink" title="2.异步"></a>2.异步</h2><p>异步方法需要重写如下方法：</p><ul><li>var isAsynchronous: Bool { get }</li><li>override var isExecuting: Bool { get }</li><li>override var isFinished: Bool { get }</li></ul><p>OperationQueue通过监听上面方法确定任务的状态，然后在start()方法中执行任务（可以调用异步方法），根据任务结果更新状态。</p><p>可重写cancel方法，cancel方法中一定要更新isFinished=true，不然operation不会从OperationQueue的operations中删除，operation会一直不会结束</p><blockquote><p>Tip：异步方法isAsynchronous需要返回true</p></blockquote><p>demo如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private class BaseOperation: Operation &#123;</span><br><span class="line">    enum State: String &#123;</span><br><span class="line">        case ready = &quot;Ready&quot;</span><br><span class="line">        case executing = &quot;Executing&quot;</span><br><span class="line">        case finished = &quot;Finished&quot;</span><br><span class="line">        fileprivate var keyPath: String &#123; return &quot;is&quot; + self.rawValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override var isAsynchronous: Bool &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    override var isExecuting: Bool &#123;</span><br><span class="line">        return state == .executing</span><br><span class="line">    &#125;</span><br><span class="line">    override var isFinished: Bool &#123;</span><br><span class="line">        return state == .finished</span><br><span class="line">    &#125;</span><br><span class="line">    private var state = State.ready &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            willChangeValue(forKey: state.keyPath)</span><br><span class="line">            willChangeValue(forKey: newValue.keyPath)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            didChangeValue(forKey: state.keyPath)</span><br><span class="line">            didChangeValue(forKey: oldValue.keyPath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func start() &#123;</span><br><span class="line">        if isCancelled &#123;</span><br><span class="line">            state = .finished</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            state = .ready</span><br><span class="line">            main()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        state = self.isCancelled ? .finished : .executing</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func finish(error: Error?) &#123;</span><br><span class="line">        state = .finished</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private class UploadOperation: BaseOperation &#123;</span><br><span class="line">    override func start() &#123;</span><br><span class="line">        super.start()</span><br><span class="line">        /// 执行任务，更新状态  </span><br><span class="line">    &#125;</span><br><span class="line">    override func cancel() &#123;</span><br><span class="line">        super.cancel()</span><br><span class="line">        /// 这里一定要更新状态</span><br><span class="line">        finish(error: nil)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自定义Operation&quot;&gt;&lt;a href=&quot;#自定义Operation&quot; class=&quot;headerlink&quot; title=&quot;自定义Operation&quot;&gt;&lt;/a&gt;自定义Operation&lt;/h1&gt;&lt;p&gt;operation分两种，同步和异步&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>swift_concurrency</title>
    <link href="http://example.com/2022/05/17/swift-concurrency/"/>
    <id>http://example.com/2022/05/17/swift-concurrency/</id>
    <published>2022-05-17T03:31:35.000Z</published>
    <updated>2022-05-19T06:50:25.352Z</updated>
    
    <content type="html"><![CDATA[<p>Swift Concurrency</p><h1 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h1><h2 id="一-怎样调用第一个async函数"><a href="#一-怎样调用第一个async函数" class="headerlink" title="一.怎样调用第一个async函数"></a>一.怎样调用第一个async函数</h2><p>情况1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func processWeather() async &#123;</span><br><span class="line">    // Do async work here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line">struct MainApp &#123;</span><br><span class="line">    static func main() async &#123;</span><br><span class="line">        await processWeather()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2：SwiftUI相关modifiers，如refreshable() and task()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    @State private var sourceCode = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        ScrollView &#123;</span><br><span class="line">            Text(sourceCode)</span><br><span class="line">        &#125;</span><br><span class="line">        .task &#123;</span><br><span class="line">            await fetchSource()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func fetchSource() async &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            let url = URL(string: &quot;https://apple.com&quot;)!</span><br><span class="line"></span><br><span class="line">            let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">            sourceCode = String(decoding: data, as: UTF8.self).trimmingCharacters(in: .whitespacesAndNewlines)</span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">            sourceCode = &quot;Failed to fetch apple.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况三：使用Task api</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Button(&quot;Go&quot;) &#123;</span><br><span class="line">Task &#123;</span><br><span class="line">await fetchSource()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-性能消耗"><a href="#2-性能消耗" class="headerlink" title="2.性能消耗"></a>2.性能消耗</h2><ul><li>只要使用await，就会产生一个潜在的暂停点，swift无法判断在暂停点是否一定会暂停，固在await出一定会产生”calling convention”消耗；</li><li>暂停点如果没有暂停，则和synchronous方式一样，没得额外消耗，如果暂停，那一定是赚了</li></ul><h2 id="3-怎样创建使用异步属性（async-properties）"><a href="#3-怎样创建使用异步属性（async-properties）" class="headerlink" title="3.怎样创建使用异步属性（async properties）"></a>3.怎样创建使用异步属性（async properties）</h2><p>异步属性只能用于<strong>只读计算属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct RemoteFile&lt;T: Decodable&gt; &#123;</span><br><span class="line">    let url: URL</span><br><span class="line">    let type: T.Type</span><br><span class="line"></span><br><span class="line">// 定义</span><br><span class="line">    var contents: T &#123;</span><br><span class="line">        get async throws &#123;</span><br><span class="line">            let (data, _) = try await URLSession.noCacheSession.data(from: url)</span><br><span class="line">            return try JSONDecoder().decode(T.self, from: data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">Task &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        messages = try await source.contents</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;Message update failed.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-async-let的使用"><a href="#4-async-let的使用" class="headerlink" title="4.async let的使用"></a>4.async let的使用</h2><p>async let，相当于DispathGroup，各个任务互相独立，同时执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func loadData() async &#123;</span><br><span class="line">    async let (userData, _) = URLSession.shared.data(from: URL(string: &quot;https://hws.dev/user-24601.json&quot;)!)</span><br><span class="line">    async let (messageData, _) = URLSession.shared.data(from: URL(string: &quot;https://hws.dev/user-messages.json&quot;)!)</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        let decoder = JSONDecoder()</span><br><span class="line">        let user = try await decoder.decode(User.self, from: userData)</span><br><span class="line">        let messages = try await decoder.decode([Message].self, from: messageData)</span><br><span class="line">        print(&quot;User \(user.name) has \(messages.count) message(s).&quot;)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;Sorry, there was a network problem.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-将block转换成async"><a href="#5-将block转换成async" class="headerlink" title="5.将block转换成async"></a>5.将block转换成async</h2><p>涉及函数<code>withCheckedContinuation </code>、<code>withUnsafeContinuation </code>、<code>withUnsafeThrowingContinuation </code>、<code>withCheckedThrowingContinuation </code>，<br>check函数会检查正确性，当多次resume，或者没有resume，都会导致crash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func fetchMessages() async -&gt; [Message] &#123;</span><br><span class="line">    await withCheckedContinuation &#123; continuation in</span><br><span class="line">        fetchMessages &#123; messages in</span><br><span class="line">            continuation.resume(returning: messages)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fetchMessages() async -&gt; [Message] &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        return try await withCheckedThrowingContinuation &#123; continuation in</span><br><span class="line">            fetchMessages &#123; messages in</span><br><span class="line">                if messages.isEmpty &#123;</span><br><span class="line">                    continuation.resume(throwing: FetchError.noMessages)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continuation.resume(returning: messages)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        return [</span><br><span class="line">            Message(id: 1, from: &quot;Tom&quot;, message: &quot;Welcome to MySpace! I&#x27;m your new friend.&quot;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-Sequences-and-streams"><a href="#二-Sequences-and-streams" class="headerlink" title="二.Sequences and streams"></a>二.Sequences and streams</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/// for in</span><br><span class="line">func fetchUsers() async throws &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/users.csv&quot;)!</span><br><span class="line"></span><br><span class="line">    for try await line in url.lines &#123;</span><br><span class="line">        print(&quot;Received user: \(line)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// Iterator</span><br><span class="line">func printUsers() async throws &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/users.csv&quot;)!</span><br><span class="line">    var iterator = url.lines.makeAsyncIterator()</span><br><span class="line"></span><br><span class="line">    if let line = try await iterator.next() &#123;</span><br><span class="line">        print(&quot;The first user is \(line)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// map\filiter\prefix...</span><br><span class="line">func shoutQuotes() async throws &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/quotes.txt&quot;)!</span><br><span class="line">    let uppercaseLines = url.lines.map(\.localizedUppercase)</span><br><span class="line"></span><br><span class="line">    for try await line in uppercaseLines &#123;</span><br><span class="line">        print(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// 返回不透明类型opaque return type</span><br><span class="line">func getQuotes() async -&gt; some AsyncSequence &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/quotes.txt&quot;)!</span><br><span class="line">    let anonymousQuotes = url.lines.filter &#123; $0.contains(&quot;Anonymous&quot;) &#125;</span><br><span class="line">    let topAnonymousQuotes = anonymousQuotes.prefix(5)</span><br><span class="line">    let shoutingTopAnonymousQuotes = topAnonymousQuotes.map(\.localizedUppercase)</span><br><span class="line">    return shoutingTopAnonymousQuotes</span><br><span class="line">&#125;</span><br><span class="line">/// convert an AsyncSequence into a Sequence</span><br><span class="line">extension AsyncSequence &#123;</span><br><span class="line">    func collect() async rethrows -&gt; [Element] &#123;</span><br><span class="line">        try await reduce(into: [Element]()) &#123; $0.append($1) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、Task-TaskGroup"><a href="#三、Task-TaskGroup" class="headerlink" title="三、Task\TaskGroup"></a>三、Task\TaskGroup</h1><h2 id="1-创建Task"><a href="#1-创建Task" class="headerlink" title="1.创建Task"></a>1.创建Task</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func fetchUpdates() async &#123;</span><br><span class="line">    let newsTask = Task &#123; () -&gt; [NewsItem] in</span><br><span class="line">        let url = URL(string: &quot;https://hws.dev/headlines.json&quot;)!</span><br><span class="line">        let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">        return try JSONDecoder().decode([NewsItem].self, from: data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        let highScores = try await highScoreTask.value</span><br><span class="line">        print(&quot;Latest news loaded with \(news.count) items.&quot;)</span><br><span class="line">        if let topScore = highScores.first &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Task-init和Task-detached的区别"><a href="#2-Task-init和Task-detached的区别" class="headerlink" title="2.Task.init和Task.detached的区别"></a>2.Task.init和Task.detached的区别</h2><h2 id="3-获取Task的结果result"><a href="#3-获取Task的结果result" class="headerlink" title="3.获取Task的结果result"></a>3.获取Task的结果result</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func fetchQuotes() async &#123;</span><br><span class="line">    let downloadTask = Task &#123; () -&gt; String in</span><br><span class="line">        let url = URL(string: &quot;https://hws.dev/quotes.txt&quot;)!</span><br><span class="line">        let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">        return String(decoding: data, as: UTF8.self)</span><br><span class="line">    &#125;</span><br><span class="line">    let result = await downloadTask.result</span><br><span class="line">    do &#123;</span><br><span class="line">        let string = try result.get()</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-取消任务"><a href="#4-取消任务" class="headerlink" title="4.取消任务"></a>4.取消任务</h2><p>检查任务：<code>Task.checkCancellation()</code>和<code>Task.isCancelled</code></p><p>取消任务：<code>task.cancel()</code></p><h2 id="5-Task睡眠"><a href="#5-Task睡眠" class="headerlink" title="5.Task睡眠"></a>5.Task睡眠</h2><p>task sleep不会导致thread block<br><code>try await Task.sleep(nanoseconds: 3_000_000_000)</code></p><h2 id="6-自愿暂停任务"><a href="#6-自愿暂停任务" class="headerlink" title="6.自愿暂停任务"></a>6.自愿暂停任务</h2><p>自愿暂停任务，可以让其他任务执行机会，但不一定会暂停（优先级最高）<br><code>await Task.yield()</code></p><h2 id="7-创建TaskGroup"><a href="#7-创建TaskGroup" class="headerlink" title="7.创建TaskGroup"></a>7.创建TaskGroup</h2><p>两个方法<code>withTaskGroup </code>和<code>withThrowingTaskGroup </code>，另外TaskGroup遵循<code>AsyncSequence </code>协议，TaskGroup只能返回同一Type数据</p><p>cancel TaskGroup分三种情况：</p><ul><li>父Task被取消</li><li>显示的调用cancelAll()</li><li>其中一个子任务throws未捕获的错误</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func loadStories() async &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        stories = try await withThrowingTaskGroup(of: [NewsStory].self) &#123; group -&gt; [NewsStory] in</span><br><span class="line">            for i in 1...5 &#123;</span><br><span class="line">                group.addTask &#123;</span><br><span class="line">                    let url = URL(string: &quot;https://hws.dev/news-\(i).json&quot;)!</span><br><span class="line">                    let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">                    return try JSONDecoder().decode([NewsStory].self, from: data)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            let allStories = try await group.reduce(into: [NewsStory]()) &#123; $0 += $1 &#125;</span><br><span class="line">            return allStories.sorted &#123; $0.id &gt; $1.id &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-处理TaskGroup返回不同数据类型"><a href="#8-处理TaskGroup返回不同数据类型" class="headerlink" title="8.处理TaskGroup返回不同数据类型"></a>8.处理TaskGroup返回不同数据类型</h2><p>两种方式：</p><ul><li>使用<code>async let</code></li><li>使用enum+关联类型</li></ul><h2 id="9-TaskLocal"><a href="#9-TaskLocal" class="headerlink" title="9.TaskLocal"></a>9.TaskLocal</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">enum User &#123;</span><br><span class="line">    @TaskLocal static var id = &quot;Anonymous&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line">struct App &#123;</span><br><span class="line">    static func main() async throws &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            try await User.$id.withValue(&quot;Piper&quot;) &#123;</span><br><span class="line">                print(&quot;Start of task: \(User.id)&quot;)</span><br><span class="line">                try await Task.sleep(nanoseconds: 1_000_000)</span><br><span class="line">                print(&quot;End of task: \(User.id)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Task &#123;</span><br><span class="line">            try await User.$id.withValue(&quot;Alex&quot;) &#123;</span><br><span class="line">                print(&quot;Start of task: \(User.id)&quot;)</span><br><span class="line">                try await Task.sleep(nanoseconds: 1_000_000)</span><br><span class="line">                print(&quot;End of task: \(User.id)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(&quot;Outside of tasks: \(User.id)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-task-modifier"><a href="#10-task-modifier" class="headerlink" title="10.task modifier"></a>10.task modifier</h2><blockquote><p>task modifier 在onAppear调用，在onDisappear时cancel，为了避免反复调用，使用task(id:)</p></blockquote><h1 id="四-Actor"><a href="#四-Actor" class="headerlink" title="四.Actor"></a>四.Actor</h1><p>actior特点如下：</p><ul><li>actor关键词同struct、class同级</li><li>actor和class一致，都是引用类型，但actor不能继承，也就不能使用final、override关键词。</li><li>actor自动继承Actor协议</li></ul><blockquote><p>actor是线程安全的，外部访问actor的mutable state需要使用await</p></blockquote><blockquote><p>使用isolated关键词，不会要求使用await</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actor DataStore &#123;</span><br><span class="line">    var username = &quot;Anonymous&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func debugLog(dataStore: isolated DataStore) &#123;</span><br><span class="line">    print(&quot;Username: \(dataStore.username)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>actor 内部使用<code>nonisolated </code>，方法和计算属性可以使用</li><li>访问使用<code>nonisolated </code>的方法属性不需要加<code>await</code></li><li>nonisolated方法内部只能访问nonisolated方法不需要加await</li><li>Codable等协议方法需要使用上<code>nonisolated </code>关键词</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">actor User &#123;</span><br><span class="line">    let username: String</span><br><span class="line">    let password: String</span><br><span class="line">    var isOnline = false</span><br><span class="line"></span><br><span class="line">    init(username: String, password: String) &#123;</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nonisolated func passwordHash() -&gt; String &#123;</span><br><span class="line">        return password</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = User(username: &quot;twostraws&quot;, password: &quot;s3kr1t&quot;)</span><br><span class="line">print(user.passwordHash())</span><br></pre></td></tr></table></figure><h2 id="1-MainActor"><a href="#1-MainActor" class="headerlink" title="1.MainActor"></a>1.MainActor</h2><p>MainActor是一个全局的actor，保证所以的work在主线程执行。<br>被@MainActor标记的方法、类型可以安全的操作UI<br>MainActor.run可以将任务放在主线程执行</p><p>demo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@MainActor</span><br><span class="line">class AccountViewModel: ObservableObject &#123;</span><br><span class="line">    @Published var username = &quot;Anonymous&quot;</span><br><span class="line">    @Published var isAuthenticated = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await MainActor.run &#123;</span><br><span class="line">    print(&quot;This is on the main actor.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task &#123;</span><br><span class="line">    await MainActor.run &#123;</span><br><span class="line">        print(&quot;This is on the main actor.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task &#123; @MainActor in</span><br><span class="line">    print(&quot;This is on the main actor.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Swift Concurrency&lt;/p&gt;
&lt;h1 id=&quot;Async-await&quot;&gt;&lt;a href=&quot;#Async-await&quot; class=&quot;headerlink&quot; title=&quot;Async/await&quot;&gt;&lt;/a&gt;Async/await&lt;/h1&gt;&lt;h2 id=&quot;一-怎样</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>xcode_preview_crash</title>
    <link href="http://example.com/2022/05/13/xcode-preview-crash/"/>
    <id>http://example.com/2022/05/13/xcode-preview-crash/</id>
    <published>2022-05-13T09:25:15.000Z</published>
    <updated>2022-05-13T09:29:48.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xcode-Preview-Crash"><a href="#Xcode-Preview-Crash" class="headerlink" title="Xcode Preview Crash"></a>Xcode Preview Crash</h1><p>结论，运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl --set previews delete all</span><br></pre></td></tr></table></figure><p>崩溃原因：使用了realmswift，然后修改了Object，按照常理说删除应用后，在migration的时候就不会崩溃；但preview不得行，一样会崩溃，猜测是preview应用缓存在其他位置，不是模拟器上看到的那个应用。</p><p>网上找到的解决方法：<br>终端运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl --set previews delete all</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Xcode-Preview-Crash&quot;&gt;&lt;a href=&quot;#Xcode-Preview-Crash&quot; class=&quot;headerlink&quot; title=&quot;Xcode Preview Crash&quot;&gt;&lt;/a&gt;Xcode Preview Crash&lt;/h1&gt;&lt;p&gt;结论</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大杂烩</title>
    <link href="http://example.com/2022/03/10/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>http://example.com/2022/03/10/%E5%A4%A7%E6%9D%82%E7%83%A9/</id>
    <published>2022-03-10T10:21:58.000Z</published>
    <updated>2022-05-19T07:29:37.830Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Xcode在Resolve Package Dependencies时候慢的解决方式</p><p> 原因：是xcode网络请求不会走代理</p><p> 解决方式：终端挂代理，在项目root path使用<code>xcodebuild -resolvePackageDependencies -scmProvider system</code></p></li><li><p>Xcode添加swift package时慢的处理方法</p><p> 使用软件Proxifier软件，在打开xcode</p></li><li><p>terminal指定应用打开文件<br><code>open -a \Application\xx.app xx</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Xcode在Resolve Package Dependencies时候慢的解决方式&lt;/p&gt;
&lt;p&gt; 原因：是xcode网络请求不会走代理&lt;/p&gt;
&lt;p&gt; 解决方式：终端挂代理，在项目root path使用&lt;code&gt;xcodebuild -resolve</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客的诞生</title>
    <link href="http://example.com/2021/12/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/"/>
    <id>http://example.com/2021/12/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/</id>
    <published>2021-12-19T06:22:33.000Z</published>
    <updated>2021-12-19T06:24:11.325Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下博客的诞生日期：2021-12-19，今天算是第一篇文章，再接再厉！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下博客的诞生日期：2021-12-19，今天算是第一篇文章，再接再厉！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
