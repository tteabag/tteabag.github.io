<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tteabag</title>
  
  <subtitle>You never know what you can do till you try!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-23T10:08:28.847Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>tteabag</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ios_exception</title>
    <link href="http://example.com/2022/09/23/ios-exception/"/>
    <id>http://example.com/2022/09/23/ios-exception/</id>
    <published>2022-09-23T08:00:27.000Z</published>
    <updated>2022-09-23T10:08:28.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Task-amp-Thread-amp-Process的区别"><a href="#Task-amp-Thread-amp-Process的区别" class="headerlink" title="Task &amp; Thread &amp; Process的区别"></a>Task &amp; Thread &amp; Process的区别</h1><p>iOS操作系统内核为XNU（混合内核），而XNU的核心为Mach微内核。</p><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>用户角度：一个可执行程序的一个实例就是一个进程，使用PID标识<br>BSD层的Process：内部包含多个线程，和Mach Task一一对应</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Mach Task是系统资源的集合，包含：一个虚拟的地址空间（分配内存），一个端口权限名称空间，一个或多个线程。</p><p>Mach Task和Process的区别：Mach Task提供更少的功能。在Process中，有信号、组、文件描述符等。而Mach Task用于资源的分配和共享，它是资源的容器。</p><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>iOS中的进程和POSIX线程（pthread）是分别基于Mach task和Mach thread的顶层实现。</p><p><img src="/./ios-exception/daaf18b3efe543daad508d0d9931ddf8~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image.jpeg"></p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h3 id="异常简述"><a href="#异常简述" class="headerlink" title="异常简述"></a>异常简述</h3><p>应用通常运行在用户态。但是，当应用需要去主动使用系统调用，或被动遇到一些异常或者中断的时，应用由用户态进入到内核态，相当于系统收回了应用的运行权限<br><img src="/./ios-exception/5f23826ebe70464097cf4e869b6fc77e~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image.jpeg"></p><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><ol><li>硬件异常：例如除0操作</li><li>软件异常：给一个不存在的对象发送了消息</li></ol><p>写的软件错误，可造成硬件异常，亦或是软件异常。而只有硬件异常才会发生上述的用户态到内核态的转化。</p><h3 id="Mach-Exception"><a href="#Mach-Exception" class="headerlink" title="Mach Exception"></a>Mach Exception</h3><h4 id="Mach-Exception的传递"><a href="#Mach-Exception的传递" class="headerlink" title="Mach Exception的传递"></a>Mach Exception的传递</h4><p>Mach内核提供了一个基于IPC的异常处理工具，其中异常被转化为message。</p><p>当异常发生时，一条包含异常的mach message，会被发送到一个异常端口。而线程（thread），任务（task），主机（host）都会维护一组异常端口，当Mach Exception机制传递异常消息的时候，它会按照thread → task → host 的顺序传递异常消息（这三者就是线程，进程，和系统的递进关系），如果这三个级别都没有处理异常成功，也就是收到KERN_SUCCESS 结果，那么内核就会终止该进程</p><h4 id="如何处理Mach-Exception？"><a href="#如何处理Mach-Exception？" class="headerlink" title="如何处理Mach Exception？"></a>如何处理Mach Exception？</h4><p>异常处理程序是mach message的接受者，它运行在自己的线程，虽然说它可以和发生异常的线程在同一个task中（也就是同一个进程中），但是它通常运行在其他的task中，比如说一个debugger。</p><p>如果一个线程想处理这个task的异常消息，那么就需要调用task_set_exception_ports() 来注册这个task的异常端口。这样的话，只要这个进程出现了硬件异常最后都会转化为Mach Exception Mesaage并传递给注册的端口，从而被异常处理程序接受到，处理接收到的异常消息。</p><h4 id="Mach-Exception分类"><a href="#Mach-Exception分类" class="headerlink" title="Mach Exception分类"></a>Mach Exception分类</h4><table><thead><tr><th>Exception</th><th>Notes</th></tr></thead><tbody><tr><td>EXC_BAD_ACCESS</td><td>无法访问内存</td></tr><tr><td>EXC_BAD_INSTRUCTION</td><td>非法或者未定义的指令或者操作数</td></tr><tr><td>EXC_ARITHMETIC</td><td>算术异常（例如被零除）</td></tr><tr><td>EXC_EMULATION</td><td>遇到仿真支持指令</td></tr><tr><td>EXC_SOFTWARE</td><td>软件生成的异常（比如浮点数计算的异常）</td></tr><tr><td>EXC_BREAKPOINT</td><td>跟踪或者断点（比如Xcode的断点，就会产生异常）</td></tr><tr><td>EXC_SYSCALL</td><td>Unix系统调用</td></tr><tr><td>EXC_MACH_SYSCALL</td><td>Mach系统调用</td></tr><tr><td>EXC_RPC_ALERTRPC</td><td>警告</td></tr></tbody></table><h3 id="Unix-Signal"><a href="#Unix-Signal" class="headerlink" title="Unix Signal"></a>Unix Signal</h3><p>Mach已经提供了底层的异常机制，但是基于Mach exception，Apple在内核的BSD层上也建立了一套信号处理系统。这是为什么呢？</p><p>原因很简单，其实就是为了兼容Unix系统。而基于Linux的安卓也是兼容Unix的，所以安卓的异常也是抛出的Signal。当然这里得说明，在现代的Unix系统中，Mach异常只是导致信号生成的一类事件，还有很多其他的事件可能也会导致信号的生成，比如：显式的调用kill(2)或者killpg(2)、子线程的状态变化等等。</p><h4 id="MachineException-转-Signal"><a href="#MachineException-转-Signal" class="headerlink" title="MachineException 转 Signal"></a>MachineException 转 Signal</h4><p>Mach异常如果没有在其他地方（thread，task）得到处理，那么它会在ux_exception() 中将其转化为对应的Unix Signal信号，以下是两者之间的转化：</p><table><thead><tr><th>Mach Exception</th><th>Unix Signal</th><th>原因</th></tr></thead><tbody><tr><td>EXC_BAD_INSTRUCTION</td><td>SIGILL</td><td>非法指令，比如除0操作，数组越界，强制解包可选形等等</td></tr><tr><td>EXC_BAD_ACCESS</td><td>SIGSEVG、SIGBUS</td><td>SIGSEVG、SIGBUS两者都是错误内存访问，但是两者之间是有区别的：SIGBUS（总线错误）是内存映射有效，但是不允许被访问； SIGSEVG（段地址错误）是内存地址映射都失效</td></tr><tr><td>EXC_ARIHMETIC</td><td>SIGFPE</td><td>运算错误，比如浮点数运算异常</td></tr><tr><td>EXC_EMULATION</td><td>SIGEM</td><td>Thardware emulation 硬件仿真指令</td></tr><tr><td>EXC_BREAKPOINT</td><td>SIGTRAP</td><td>trace、breakpoint等等，比如说使用Xcode的断点</td></tr><tr><td>EXC_SOFTWARE</td><td>SIGABRT、SIGPIPE、SIGSYS、SIGKILL</td><td>软件错误，其中SIGABRT最为常见。</td></tr></tbody></table><h4 id="软件异常转Signal"><a href="#软件异常转Signal" class="headerlink" title="软件异常转Signal"></a>软件异常转Signal</h4><p>除了上述引发CPU Trap的异常之外，还有一类异常是软件异常，这一类异常并不会让进程进入内核态，所以它也并不会转化为Mach Exception，而是会直接转化为Unix Signal。而由Objective-C产生的异常就是软件异常这一类，它将直接转换为Signal信号，比如给对象发送未实现的消息，数组索引越界直接引发SIGABRT信号，作为对比Swift的数组异常会导致CPU Trap，转化为EXC_BAD_INSTRUCTION异常消息。</p><h4 id="Mach-Exception和Unix-Signal的区别"><a href="#Mach-Exception和Unix-Signal的区别" class="headerlink" title="Mach Exception和Unix Signal的区别"></a>Mach Exception和Unix Signal的区别</h4><p>Mach Exception的处理机制中异常处理程序可以在自己创建的处理线程中运行，而该线程和出错的线程甚至可以不在一个task中，即可以不在一个进程中，因此异常处理不需要错误线程的资源来运行，这样可以在需要的时候直接获得错误线程的异常上下文</p><p>而Unix Signal的处理无法运行在其他的线程，只能在错误线程上处理</p><p>所以Mach异常处理机制的优势是很明显的，比如说debugging场景，我们平时打断点的时候，其实程序运行到这里的时候会给Xcode这个task中的注册异常端口发EXC_BREAKPOINT消息，而Xcode收到之后，就会暂停在断点处，在处理完之后（比如点击跳过断点），将发送消息返回到Xcode，Xcode也将继续跑下去。</p><h1 id="iOS异常捕获三方"><a href="#iOS异常捕获三方" class="headerlink" title="iOS异常捕获三方"></a>iOS异常捕获三方</h1><ol><li><p>SKCrash</p></li><li><p>PLCrashReport</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/7142656591139962888">你真的懂iOS的异常捕获吗？ - 掘金</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Task-amp-Thread-amp-Process的区别&quot;&gt;&lt;a href=&quot;#Task-amp-Thread-amp-Process的区别&quot; class=&quot;headerlink&quot; title=&quot;Task &amp;amp; Thread &amp;amp; Process的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>operation_queue</title>
    <link href="http://example.com/2022/05/19/%E8%87%AA%E5%AE%9A%E4%B9%89Operation/"/>
    <id>http://example.com/2022/05/19/%E8%87%AA%E5%AE%9A%E4%B9%89Operation/</id>
    <published>2022-05-19T06:52:13.000Z</published>
    <updated>2022-05-19T08:11:36.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义Operation"><a href="#自定义Operation" class="headerlink" title="自定义Operation"></a>自定义Operation</h1><p>operation分两种，同步和异步</p><h2 id="1-同步"><a href="#1-同步" class="headerlink" title="1.同步"></a>1.同步</h2><p> 同步的定义，只需要重写main()方法，main方法内部不能调用其他异步函数，因为main()方法执行完成，operation即执行结束。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SyncOperation: Operation &#123;   </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        print(&quot;执行同步任务&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-异步"><a href="#2-异步" class="headerlink" title="2.异步"></a>2.异步</h2><p>异步方法需要重写如下方法：</p><ul><li>var isAsynchronous: Bool { get }</li><li>override var isExecuting: Bool { get }</li><li>override var isFinished: Bool { get }</li></ul><p>OperationQueue通过监听上面方法确定任务的状态，然后在start()方法中执行任务（可以调用异步方法），根据任务结果更新状态。</p><p>可重写cancel方法，cancel方法中一定要更新isFinished=true，不然operation不会从OperationQueue的operations中删除，operation会一直不会结束</p><blockquote><p>Tip：异步方法isAsynchronous需要返回true</p></blockquote><p>demo如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private class BaseOperation: Operation &#123;</span><br><span class="line">    enum State: String &#123;</span><br><span class="line">        case ready = &quot;Ready&quot;</span><br><span class="line">        case executing = &quot;Executing&quot;</span><br><span class="line">        case finished = &quot;Finished&quot;</span><br><span class="line">        fileprivate var keyPath: String &#123; return &quot;is&quot; + self.rawValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override var isAsynchronous: Bool &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    override var isExecuting: Bool &#123;</span><br><span class="line">        return state == .executing</span><br><span class="line">    &#125;</span><br><span class="line">    override var isFinished: Bool &#123;</span><br><span class="line">        return state == .finished</span><br><span class="line">    &#125;</span><br><span class="line">    private var state = State.ready &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            willChangeValue(forKey: state.keyPath)</span><br><span class="line">            willChangeValue(forKey: newValue.keyPath)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            didChangeValue(forKey: state.keyPath)</span><br><span class="line">            didChangeValue(forKey: oldValue.keyPath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func start() &#123;</span><br><span class="line">        if isCancelled &#123;</span><br><span class="line">            state = .finished</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            state = .ready</span><br><span class="line">            main()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func main() &#123;</span><br><span class="line">        state = self.isCancelled ? .finished : .executing</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func finish(error: Error?) &#123;</span><br><span class="line">        state = .finished</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private class UploadOperation: BaseOperation &#123;</span><br><span class="line">    override func start() &#123;</span><br><span class="line">        super.start()</span><br><span class="line">        /// 执行任务，更新状态  </span><br><span class="line">    &#125;</span><br><span class="line">    override func cancel() &#123;</span><br><span class="line">        super.cancel()</span><br><span class="line">        /// 这里一定要更新状态</span><br><span class="line">        finish(error: nil)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;自定义Operation&quot;&gt;&lt;a href=&quot;#自定义Operation&quot; class=&quot;headerlink&quot; title=&quot;自定义Operation&quot;&gt;&lt;/a&gt;自定义Operation&lt;/h1&gt;&lt;p&gt;operation分两种，同步和异步&lt;/p&gt;
&lt;h2 id=&quot;1-同步&quot;&gt;&lt;a href=&quot;#1-同步&quot; class=&quot;headerlink&quot; title=&quot;1.同步&quot;&gt;&lt;/a&gt;1.同步&lt;/h2&gt;&lt;p&gt; 同步的定义，只需要重写main()方法，main方法内部不能调用其他异步函数，因为main()方法执行完成，operation即执行结束。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>swift_concurrency</title>
    <link href="http://example.com/2022/05/17/Swift%20Concurrency/"/>
    <id>http://example.com/2022/05/17/Swift%20Concurrency/</id>
    <published>2022-05-17T03:31:35.000Z</published>
    <updated>2022-05-19T08:11:24.746Z</updated>
    
    <content type="html"><![CDATA[<p>Swift Concurrency</p><h1 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h1><h2 id="一-怎样调用第一个async函数"><a href="#一-怎样调用第一个async函数" class="headerlink" title="一.怎样调用第一个async函数"></a>一.怎样调用第一个async函数</h2><p>情况1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func processWeather() async &#123;</span><br><span class="line">    // Do async work here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line">struct MainApp &#123;</span><br><span class="line">    static func main() async &#123;</span><br><span class="line">        await processWeather()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>情况2：SwiftUI相关modifiers，如refreshable() and task()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    @State private var sourceCode = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        ScrollView &#123;</span><br><span class="line">            Text(sourceCode)</span><br><span class="line">        &#125;</span><br><span class="line">        .task &#123;</span><br><span class="line">            await fetchSource()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func fetchSource() async &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            let url = URL(string: &quot;https://apple.com&quot;)!</span><br><span class="line"></span><br><span class="line">            let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">            sourceCode = String(decoding: data, as: UTF8.self).trimmingCharacters(in: .whitespacesAndNewlines)</span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">            sourceCode = &quot;Failed to fetch apple.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况三：使用Task api</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Button(&quot;Go&quot;) &#123;</span><br><span class="line">Task &#123;</span><br><span class="line">await fetchSource()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-性能消耗"><a href="#2-性能消耗" class="headerlink" title="2.性能消耗"></a>2.性能消耗</h2><ul><li>只要使用await，就会产生一个潜在的暂停点，swift无法判断在暂停点是否一定会暂停，固在await出一定会产生”calling convention”消耗；</li><li>暂停点如果没有暂停，则和synchronous方式一样，没得额外消耗，如果暂停，那一定是赚了</li></ul><h2 id="3-怎样创建使用异步属性（async-properties）"><a href="#3-怎样创建使用异步属性（async-properties）" class="headerlink" title="3.怎样创建使用异步属性（async properties）"></a>3.怎样创建使用异步属性（async properties）</h2><p>异步属性只能用于<strong>只读计算属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct RemoteFile&lt;T: Decodable&gt; &#123;</span><br><span class="line">    let url: URL</span><br><span class="line">    let type: T.Type</span><br><span class="line"></span><br><span class="line">// 定义</span><br><span class="line">    var contents: T &#123;</span><br><span class="line">        get async throws &#123;</span><br><span class="line">            let (data, _) = try await URLSession.noCacheSession.data(from: url)</span><br><span class="line">            return try JSONDecoder().decode(T.self, from: data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">Task &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        messages = try await source.contents</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;Message update failed.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-async-let的使用"><a href="#4-async-let的使用" class="headerlink" title="4.async let的使用"></a>4.async let的使用</h2><p>async let，相当于DispathGroup，各个任务互相独立，同时执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func loadData() async &#123;</span><br><span class="line">    async let (userData, _) = URLSession.shared.data(from: URL(string: &quot;https://hws.dev/user-24601.json&quot;)!)</span><br><span class="line">    async let (messageData, _) = URLSession.shared.data(from: URL(string: &quot;https://hws.dev/user-messages.json&quot;)!)</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        let decoder = JSONDecoder()</span><br><span class="line">        let user = try await decoder.decode(User.self, from: userData)</span><br><span class="line">        let messages = try await decoder.decode([Message].self, from: messageData)</span><br><span class="line">        print(&quot;User \(user.name) has \(messages.count) message(s).&quot;)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;Sorry, there was a network problem.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-将block转换成async"><a href="#5-将block转换成async" class="headerlink" title="5.将block转换成async"></a>5.将block转换成async</h2><p>涉及函数<code>withCheckedContinuation </code>、<code>withUnsafeContinuation </code>、<code>withUnsafeThrowingContinuation </code>、<code>withCheckedThrowingContinuation </code>，<br>check函数会检查正确性，当多次resume，或者没有resume，都会导致crash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func fetchMessages() async -&gt; [Message] &#123;</span><br><span class="line">    await withCheckedContinuation &#123; continuation in</span><br><span class="line">        fetchMessages &#123; messages in</span><br><span class="line">            continuation.resume(returning: messages)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fetchMessages() async -&gt; [Message] &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        return try await withCheckedThrowingContinuation &#123; continuation in</span><br><span class="line">            fetchMessages &#123; messages in</span><br><span class="line">                if messages.isEmpty &#123;</span><br><span class="line">                    continuation.resume(throwing: FetchError.noMessages)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continuation.resume(returning: messages)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        return [</span><br><span class="line">            Message(id: 1, from: &quot;Tom&quot;, message: &quot;Welcome to MySpace! I&#x27;m your new friend.&quot;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-Sequences-and-streams"><a href="#二-Sequences-and-streams" class="headerlink" title="二.Sequences and streams"></a>二.Sequences and streams</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/// for in</span><br><span class="line">func fetchUsers() async throws &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/users.csv&quot;)!</span><br><span class="line"></span><br><span class="line">    for try await line in url.lines &#123;</span><br><span class="line">        print(&quot;Received user: \(line)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// Iterator</span><br><span class="line">func printUsers() async throws &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/users.csv&quot;)!</span><br><span class="line">    var iterator = url.lines.makeAsyncIterator()</span><br><span class="line"></span><br><span class="line">    if let line = try await iterator.next() &#123;</span><br><span class="line">        print(&quot;The first user is \(line)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// map\filiter\prefix...</span><br><span class="line">func shoutQuotes() async throws &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/quotes.txt&quot;)!</span><br><span class="line">    let uppercaseLines = url.lines.map(\.localizedUppercase)</span><br><span class="line"></span><br><span class="line">    for try await line in uppercaseLines &#123;</span><br><span class="line">        print(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// 返回不透明类型opaque return type</span><br><span class="line">func getQuotes() async -&gt; some AsyncSequence &#123;</span><br><span class="line">    let url = URL(string: &quot;https://hws.dev/quotes.txt&quot;)!</span><br><span class="line">    let anonymousQuotes = url.lines.filter &#123; $0.contains(&quot;Anonymous&quot;) &#125;</span><br><span class="line">    let topAnonymousQuotes = anonymousQuotes.prefix(5)</span><br><span class="line">    let shoutingTopAnonymousQuotes = topAnonymousQuotes.map(\.localizedUppercase)</span><br><span class="line">    return shoutingTopAnonymousQuotes</span><br><span class="line">&#125;</span><br><span class="line">/// convert an AsyncSequence into a Sequence</span><br><span class="line">extension AsyncSequence &#123;</span><br><span class="line">    func collect() async rethrows -&gt; [Element] &#123;</span><br><span class="line">        try await reduce(into: [Element]()) &#123; $0.append($1) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、Task-TaskGroup"><a href="#三、Task-TaskGroup" class="headerlink" title="三、Task\TaskGroup"></a>三、Task\TaskGroup</h1><h2 id="1-创建Task"><a href="#1-创建Task" class="headerlink" title="1.创建Task"></a>1.创建Task</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func fetchUpdates() async &#123;</span><br><span class="line">    let newsTask = Task &#123; () -&gt; [NewsItem] in</span><br><span class="line">        let url = URL(string: &quot;https://hws.dev/headlines.json&quot;)!</span><br><span class="line">        let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">        return try JSONDecoder().decode([NewsItem].self, from: data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        let highScores = try await highScoreTask.value</span><br><span class="line">        print(&quot;Latest news loaded with \(news.count) items.&quot;)</span><br><span class="line">        if let topScore = highScores.first &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Task-init和Task-detached的区别"><a href="#2-Task-init和Task-detached的区别" class="headerlink" title="2.Task.init和Task.detached的区别"></a>2.Task.init和Task.detached的区别</h2><h2 id="3-获取Task的结果result"><a href="#3-获取Task的结果result" class="headerlink" title="3.获取Task的结果result"></a>3.获取Task的结果result</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func fetchQuotes() async &#123;</span><br><span class="line">    let downloadTask = Task &#123; () -&gt; String in</span><br><span class="line">        let url = URL(string: &quot;https://hws.dev/quotes.txt&quot;)!</span><br><span class="line">        let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">        return String(decoding: data, as: UTF8.self)</span><br><span class="line">    &#125;</span><br><span class="line">    let result = await downloadTask.result</span><br><span class="line">    do &#123;</span><br><span class="line">        let string = try result.get()</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-取消任务"><a href="#4-取消任务" class="headerlink" title="4.取消任务"></a>4.取消任务</h2><p>检查任务：<code>Task.checkCancellation()</code>和<code>Task.isCancelled</code></p><p>取消任务：<code>task.cancel()</code></p><h2 id="5-Task睡眠"><a href="#5-Task睡眠" class="headerlink" title="5.Task睡眠"></a>5.Task睡眠</h2><p>task sleep不会导致thread block<br><code>try await Task.sleep(nanoseconds: 3_000_000_000)</code></p><h2 id="6-自愿暂停任务"><a href="#6-自愿暂停任务" class="headerlink" title="6.自愿暂停任务"></a>6.自愿暂停任务</h2><p>自愿暂停任务，可以让其他任务执行机会，但不一定会暂停（优先级最高）<br><code>await Task.yield()</code></p><h2 id="7-创建TaskGroup"><a href="#7-创建TaskGroup" class="headerlink" title="7.创建TaskGroup"></a>7.创建TaskGroup</h2><p>两个方法<code>withTaskGroup </code>和<code>withThrowingTaskGroup </code>，另外TaskGroup遵循<code>AsyncSequence </code>协议，TaskGroup只能返回同一Type数据</p><p>cancel TaskGroup分三种情况：</p><ul><li>父Task被取消</li><li>显示的调用cancelAll()</li><li>其中一个子任务throws未捕获的错误</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func loadStories() async &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        stories = try await withThrowingTaskGroup(of: [NewsStory].self) &#123; group -&gt; [NewsStory] in</span><br><span class="line">            for i in 1...5 &#123;</span><br><span class="line">                group.addTask &#123;</span><br><span class="line">                    let url = URL(string: &quot;https://hws.dev/news-\(i).json&quot;)!</span><br><span class="line">                    let (data, _) = try await URLSession.shared.data(from: url)</span><br><span class="line">                    return try JSONDecoder().decode([NewsStory].self, from: data)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            let allStories = try await group.reduce(into: [NewsStory]()) &#123; $0 += $1 &#125;</span><br><span class="line">            return allStories.sorted &#123; $0.id &gt; $1.id &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-处理TaskGroup返回不同数据类型"><a href="#8-处理TaskGroup返回不同数据类型" class="headerlink" title="8.处理TaskGroup返回不同数据类型"></a>8.处理TaskGroup返回不同数据类型</h2><p>两种方式：</p><ul><li>使用<code>async let</code></li><li>使用enum+关联类型</li></ul><h2 id="9-TaskLocal"><a href="#9-TaskLocal" class="headerlink" title="9.TaskLocal"></a>9.TaskLocal</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">enum User &#123;</span><br><span class="line">    @TaskLocal static var id = &quot;Anonymous&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line">struct App &#123;</span><br><span class="line">    static func main() async throws &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            try await User.$id.withValue(&quot;Piper&quot;) &#123;</span><br><span class="line">                print(&quot;Start of task: \(User.id)&quot;)</span><br><span class="line">                try await Task.sleep(nanoseconds: 1_000_000)</span><br><span class="line">                print(&quot;End of task: \(User.id)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Task &#123;</span><br><span class="line">            try await User.$id.withValue(&quot;Alex&quot;) &#123;</span><br><span class="line">                print(&quot;Start of task: \(User.id)&quot;)</span><br><span class="line">                try await Task.sleep(nanoseconds: 1_000_000)</span><br><span class="line">                print(&quot;End of task: \(User.id)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(&quot;Outside of tasks: \(User.id)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-task-modifier"><a href="#10-task-modifier" class="headerlink" title="10.task modifier"></a>10.task modifier</h2><blockquote><p>task modifier 在onAppear调用，在onDisappear时cancel，为了避免反复调用，使用task(id:)</p></blockquote><h1 id="四-Actor"><a href="#四-Actor" class="headerlink" title="四.Actor"></a>四.Actor</h1><p>actior特点如下：</p><ul><li>actor关键词同struct、class同级</li><li>actor和class一致，都是引用类型，但actor不能继承，也就不能使用final、override关键词。</li><li>actor自动继承Actor协议</li></ul><blockquote><p>actor是线程安全的，外部访问actor的mutable state需要使用await</p></blockquote><blockquote><p>使用isolated关键词，不会要求使用await</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actor DataStore &#123;</span><br><span class="line">    var username = &quot;Anonymous&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func debugLog(dataStore: isolated DataStore) &#123;</span><br><span class="line">    print(&quot;Username: \(dataStore.username)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>actor 内部使用<code>nonisolated </code>，方法和计算属性可以使用</li><li>访问使用<code>nonisolated </code>的方法属性不需要加<code>await</code></li><li>nonisolated方法内部只能访问nonisolated方法不需要加await</li><li>Codable等协议方法需要使用上<code>nonisolated </code>关键词</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">actor User &#123;</span><br><span class="line">    let username: String</span><br><span class="line">    let password: String</span><br><span class="line">    var isOnline = false</span><br><span class="line"></span><br><span class="line">    init(username: String, password: String) &#123;</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nonisolated func passwordHash() -&gt; String &#123;</span><br><span class="line">        return password</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = User(username: &quot;twostraws&quot;, password: &quot;s3kr1t&quot;)</span><br><span class="line">print(user.passwordHash())</span><br></pre></td></tr></table></figure><h2 id="1-MainActor"><a href="#1-MainActor" class="headerlink" title="1.MainActor"></a>1.MainActor</h2><p>MainActor是一个全局的actor，保证所以的work在主线程执行。<br>被@MainActor标记的方法、类型可以安全的操作UI<br>MainActor.run可以将任务放在主线程执行</p><p>demo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@MainActor</span><br><span class="line">class AccountViewModel: ObservableObject &#123;</span><br><span class="line">    @Published var username = &quot;Anonymous&quot;</span><br><span class="line">    @Published var isAuthenticated = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await MainActor.run &#123;</span><br><span class="line">    print(&quot;This is on the main actor.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task &#123;</span><br><span class="line">    await MainActor.run &#123;</span><br><span class="line">        print(&quot;This is on the main actor.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task &#123; @MainActor in</span><br><span class="line">    print(&quot;This is on the main actor.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Swift Concurrency&lt;/p&gt;
&lt;h1 id=&quot;Async-await&quot;&gt;&lt;a href=&quot;#Async-await&quot; class=&quot;headerlink&quot; title=&quot;Async/await&quot;&gt;&lt;/a&gt;Async/await&lt;/h1&gt;&lt;h2 id=&quot;一-怎样调用第一个async函数&quot;&gt;&lt;a href=&quot;#一-怎样调用第一个async函数&quot; class=&quot;headerlink&quot; title=&quot;一.怎样调用第一个async函数&quot;&gt;&lt;/a&gt;一.怎样调用第一个async函数&lt;/h2&gt;&lt;p&gt;情况1：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func processWeather() async &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Do async work here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct MainApp &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static func main() async &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        await processWeather()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>xcode_preview_crash</title>
    <link href="http://example.com/2022/05/13/Xcode%20preview%20crash/"/>
    <id>http://example.com/2022/05/13/Xcode%20preview%20crash/</id>
    <published>2022-05-13T09:25:15.000Z</published>
    <updated>2022-05-13T09:29:48.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xcode-Preview-Crash"><a href="#Xcode-Preview-Crash" class="headerlink" title="Xcode Preview Crash"></a>Xcode Preview Crash</h1><p>结论，运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl --set previews delete all</span><br></pre></td></tr></table></figure><p>崩溃原因：使用了realmswift，然后修改了Object，按照常理说删除应用后，在migration的时候就不会崩溃；但preview不得行，一样会崩溃，猜测是preview应用缓存在其他位置，不是模拟器上看到的那个应用。</p><p>网上找到的解决方法：<br>终端运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl --set previews delete all</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Xcode-Preview-Crash&quot;&gt;&lt;a href=&quot;#Xcode-Preview-Crash&quot; class=&quot;headerlink&quot; title=&quot;Xcode Preview Crash&quot;&gt;&lt;/a&gt;Xcode Preview Crash&lt;/h1&gt;&lt;p&gt;结论</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大杂烩</title>
    <link href="http://example.com/2022/03/10/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>http://example.com/2022/03/10/%E5%A4%A7%E6%9D%82%E7%83%A9/</id>
    <published>2022-03-10T10:21:58.000Z</published>
    <updated>2022-05-19T08:12:15.783Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Xcode在Resolve Package Dependencies时候慢的解决方式</p><p> 原因：是xcode网络请求不会走代理</p><p> 解决方式：终端挂代理，在项目root path使用<code>xcodebuild -resolvePackageDependencies -scmProvider system</code></p></li><li><p>Xcode添加swift package时慢的处理方法</p><p> 使用软件Proxifier软件，在打开xcode</p></li><li><p>terminal指定应用打开文件<br><code>open -a \Application\xx.app xx</code></p></li></ol><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Xcode在Resolve Package Dependencies时候慢的解决方式&lt;/p&gt;
&lt;p&gt; 原因：是xcode网络请求不会走代理&lt;/p&gt;
&lt;p&gt; 解决方式：终端挂代理，在项目root path使用&lt;code&gt;xcodebuild -resolvePackageDependencies -scmProvider system&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Xcode添加swift package时慢的处理方法&lt;/p&gt;
&lt;p&gt; 使用软件Proxifier软件，在打开xcode&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;terminal指定应用打开文件&lt;br&gt;&lt;code&gt;open -a \Application\xx.app xx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>博客的诞生</title>
    <link href="http://example.com/2021/12/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/"/>
    <id>http://example.com/2021/12/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/</id>
    <published>2021-12-19T06:22:33.000Z</published>
    <updated>2021-12-19T06:24:11.325Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下博客的诞生日期：2021-12-19，今天算是第一篇文章，再接再厉！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下博客的诞生日期：2021-12-19，今天算是第一篇文章，再接再厉！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
